// Generated by dart2js (, trust primitives, omit checks, lax runtime type, csp, intern-composite-values), the Dart to JavaScript compiler version: 3.8.0.
((s, d, e) => {
  s[d] = s[d] || {};
  s[d][e] = s[d][e] || [];
  s[d][e].push({p: "main.dart.js_41", e: "beginPart"});
})(self, "$__dart_deferred_initializers__", "eventLog");
$__dart_deferred_initializers__.current = function(hunkHelpers, init, holdersList, $) {
  var J, B, C,
  A = {
    _sample(colors, stops, t) {
      var index, t1, t2, t3, t4;
      if (t <= C.JSArray_methods.get$first(stops))
        return C.JSArray_methods.get$first(colors);
      if (t >= C.JSArray_methods.get$last(stops))
        return C.JSArray_methods.get$last(colors);
      index = C.JSArray_methods.lastIndexWhere$1(stops, new A._sample_closure(t));
      t1 = colors[index];
      t2 = index + 1;
      t3 = colors[t2];
      t4 = stops[index];
      t4 = B.Color_lerp(t1, t3, (t - t4) / (stops[t2] - t4));
      t4.toString;
      return t4;
    },
    _interpolateColorsAndStops(aColors, aStops, bColors, bStops, t) {
      var t1, interpolatedStops,
        stops = B.SplayTreeSet$(null, null, type$.double);
      stops.addAll$1(0, aStops);
      stops.addAll$1(0, bStops);
      t1 = B.List_List$_of(stops, stops.$ti._precomputed1);
      t1.$flags = 1;
      interpolatedStops = t1;
      t1 = B._arrayInstanceType(interpolatedStops)._eval$1("MappedListIterable<1,Color>");
      t1 = B.List_List$_of(new B.MappedListIterable(interpolatedStops, new A._interpolateColorsAndStops_closure(aColors, aStops, bColors, bStops, t), t1), t1._eval$1("ListIterable.E"));
      t1.$flags = 1;
      return new A._ColorsAndStops(t1, interpolatedStops);
    },
    LinearGradient_lerp(a, b, t) {
      var interpolated, t1, t2, t3, t4;
      if (a == b)
        return a;
      if (a == null)
        return b.scale$1(t);
      if (b == null)
        return a.scale$1(1 - t);
      interpolated = A._interpolateColorsAndStops(a.colors, a._impliedStops$0(), b.colors, b._impliedStops$0(), t);
      t1 = B.AlignmentGeometry_lerp(a.begin, b.begin, t);
      t1.toString;
      t2 = B.AlignmentGeometry_lerp(a.end, b.end, t);
      t2.toString;
      t3 = t < 0.5;
      t4 = t3 ? a.tileMode : b.tileMode;
      t3 = t3 ? a.transform : b.transform;
      return new A.LinearGradient(t1, t2, t4, interpolated.colors, interpolated.stops, t3);
    },
    _ColorsAndStops: function _ColorsAndStops(t0, t1) {
      this.colors = t0;
      this.stops = t1;
    },
    _sample_closure: function _sample_closure(t0) {
      this.t = t0;
    },
    _interpolateColorsAndStops_closure: function _interpolateColorsAndStops_closure(t0, t1, t2, t3, t4) {
      var _ = this;
      _.aColors = t0;
      _.aStops = t1;
      _.bColors = t2;
      _.bStops = t3;
      _.t = t4;
    },
    Gradient: function Gradient() {
    },
    LinearGradient: function LinearGradient(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.begin = t0;
      _.end = t1;
      _.tileMode = t2;
      _.colors = t3;
      _.stops = t4;
      _.transform = t5;
    },
    LinearGradient_scale_closure: function LinearGradient_scale_closure(t0) {
      this.factor = t0;
    }
  };
  J = holdersList[1];
  B = holdersList[0];
  C = holdersList[2];
  A = hunkHelpers.updateHolder(holdersList[47], A);
  A._ColorsAndStops.prototype = {};
  A.Gradient.prototype = {
    _impliedStops$0() {
      var separation, _list, index,
        t1 = this.stops;
      if (t1 != null)
        return t1;
      t1 = this.colors.length;
      separation = 1 / (t1 - 1);
      _list = J.JSArray_JSArray$allocateFixed(t1, type$.double);
      for (index = 0; index < t1; ++index)
        _list[index] = index * separation;
      return _list;
    }
  };
  A.LinearGradient.prototype = {
    createShader$2$textDirection(rect, textDirection) {
      var _this = this,
        t1 = _this.begin.resolve$1(textDirection).withinRect$1(rect),
        t2 = _this.end.resolve$1(textDirection).withinRect$1(rect),
        t3 = _this._impliedStops$0();
      return B.Gradient_Gradient$linear(t1, t2, _this.colors, t3, _this.tileMode, null);
    },
    createShader$1(rect) {
      return this.createShader$2$textDirection(rect, null);
    },
    scale$1(factor) {
      var _this = this,
        t1 = _this.colors,
        t2 = B._arrayInstanceType(t1)._eval$1("MappedListIterable<1,Color>");
      t1 = B.List_List$_of(new B.MappedListIterable(t1, new A.LinearGradient_scale_closure(factor), t2), t2._eval$1("ListIterable.E"));
      return new A.LinearGradient(_this.begin, _this.end, _this.tileMode, t1, _this.stops, null);
    },
    lerpFrom$2(a, t) {
      var t1 = A.LinearGradient_lerp(a, this, t);
      return t1;
    },
    lerpTo$2(b, t) {
      var t1 = A.LinearGradient_lerp(this, b, t);
      return t1;
    },
    $eq(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (J.get$runtimeType$(other) !== B.getRuntimeTypeOfDartObject(_this))
        return false;
      return other instanceof A.LinearGradient && other.begin.$eq(0, _this.begin) && other.end.$eq(0, _this.end) && other.tileMode === _this.tileMode && B.listEquals(other.colors, _this.colors) && B.listEquals(other.stops, _this.stops);
    },
    get$hashCode(_) {
      var _this = this,
        t1 = B.Object_hashAll(_this.colors),
        t2 = _this.stops;
      t2 = t2 == null ? null : B.Object_hashAll(t2);
      return B.Object_hash(_this.begin, _this.end, _this.tileMode, _this.transform, t1, t2, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue);
    },
    toString$0(_) {
      var _this = this,
        t1 = B._setArrayType(["begin: " + _this.begin.toString$0(0), "end: " + _this.end.toString$0(0), "colors: " + B.S(_this.colors)], type$.JSArray_String),
        t2 = _this.stops;
      if (t2 != null)
        t1.push("stops: " + B.S(t2));
      t1.push("tileMode: " + _this.tileMode.toString$0(0));
      return "LinearGradient(" + C.JSArray_methods.join$1(t1, ", ") + ")";
    }
  };
  var typesOffset = hunkHelpers.updateTypes([]);
  A._sample_closure.prototype = {
    call$1(s) {
      return s <= this.t;
    },
    $signature: 573
  };
  A._interpolateColorsAndStops_closure.prototype = {
    call$1($stop) {
      var _this = this,
        t1 = B.Color_lerp(A._sample(_this.aColors, _this.aStops, $stop), A._sample(_this.bColors, _this.bStops, $stop), _this.t);
      t1.toString;
      return t1;
    },
    $signature: 574
  };
  A.LinearGradient_scale_closure.prototype = {
    call$1(color) {
      var t1 = B.Color_lerp(null, color, this.factor);
      t1.toString;
      return t1;
    },
    $signature: 83
  };
  (function inheritance() {
    var _inheritMany = hunkHelpers.inheritMany,
      _inherit = hunkHelpers.inherit;
    _inheritMany(B.Object, [A._ColorsAndStops, A.Gradient]);
    _inheritMany(B.Closure, [A._sample_closure, A._interpolateColorsAndStops_closure, A.LinearGradient_scale_closure]);
    _inherit(A.LinearGradient, A.Gradient);
  })();
  var type$ = {
    JSArray_String: B.findType("JSArray<String>"),
    double: B.findType("double")
  };
};
;
((d, h) => {
  d[h] = d.current;
  d.eventLog.push({p: "main.dart.js_41", e: "endPart", h: h});
})($__dart_deferred_initializers__, "rSlGhIXHdwyH4aTPyH+HBeFg71c=");
;