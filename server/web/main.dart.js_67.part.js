// Generated by dart2js (, trust primitives, omit checks, lax runtime type, csp, intern-composite-values), the Dart to JavaScript compiler version: 3.8.0.
((s, d, e) => {
  s[d] = s[d] || {};
  s[d][e] = s[d][e] || [];
  s[d][e].push({p: "main.dart.js_67", e: "beginPart"});
})(self, "$__dart_deferred_initializers__", "eventLog");
$__dart_deferred_initializers__.current = function(hunkHelpers, init, holdersList, $) {
  var J, B, C, N, K, O, P, Q, R, S, G, T, U, V, W, X, Y, F, H,
  A = {
    HttpException$(message, uri) {
      return new A.HttpException(message, uri);
    },
    _HeaderValue__isToken(token) {
      var i, codeUnit,
        t1 = token.length;
      if (t1 === 0)
        return false;
      for (i = 0; i < t1; ++i) {
        codeUnit = token.charCodeAt(i);
        if (codeUnit <= 32 || codeUnit >= 127 || C.JSString_methods.contains$1('"(),/:;<=>?@[]{}', token[i]))
          return false;
      }
      return true;
    },
    HttpException: function HttpException(t0, t1) {
      this.message = t0;
      this.uri = t1;
    },
    _HeaderValue: function _HeaderValue() {
    },
    _HeaderValue_toString_closure: function _HeaderValue_toString_closure(t0) {
      this.sb = t0;
    },
    _HeaderValue__parse_done: function _HeaderValue__parse_done(t0, t1) {
      this._box_0 = t0;
      this.s = t1;
    },
    _HeaderValue__parse_skipWS: function _HeaderValue__parse_skipWS(t0, t1, t2) {
      this._box_0 = t0;
      this.done = t1;
      this.s = t2;
    },
    _HeaderValue__parse_parseValue: function _HeaderValue__parse_parseValue(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_0 = t0;
      _.done = t1;
      _.s = t2;
      _.valueSeparator = t3;
      _.parameterSeparator = t4;
    },
    _HeaderValue__parse_expect: function _HeaderValue__parse_expect(t0, t1, t2) {
      this._box_0 = t0;
      this.done = t1;
      this.s = t2;
    },
    _HeaderValue__parse_maybeExpect: function _HeaderValue__parse_maybeExpect(t0, t1, t2) {
      this._box_0 = t0;
      this.done = t1;
      this.s = t2;
    },
    _HeaderValue__parse_parseParameters: function _HeaderValue__parse_parseParameters(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.done = t2;
      _.s = t3;
      _.parameterSeparator = t4;
      _.valueSeparator = t5;
      _.preserveBackslash = t6;
      _.parseValue = t7;
      _.skipWS = t8;
      _.maybeExpect = t9;
      _.expect = t10;
    },
    _HeaderValue__parse_parseParameters_parseParameterName: function _HeaderValue__parse_parseParameters_parseParameterName(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_0 = t0;
      _.done = t1;
      _.s = t2;
      _.parameterSeparator = t3;
      _.valueSeparator = t4;
    },
    _HeaderValue__parse_parseParameters_parseParameterValue: function _HeaderValue__parse_parseParameters_parseParameterValue(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_0 = t0;
      _.done = t1;
      _.s = t2;
      _.preserveBackslash = t3;
      _.parseValue = t4;
    },
    _ContentType: function _ContentType() {
      var _ = this;
      _.__http$_value = _._subType = _._primaryType = "";
      _._parameters = null;
    },
    Future_Future$microtask(computation, $T) {
      var result = new B._Future($.Zone__current, $T._eval$1("_Future<0>"));
      B.scheduleMicrotask(new A.Future_Future$microtask_closure(computation, result));
      return result;
    },
    Future_Future$microtask_closure: function Future_Future$microtask_closure(t0, t1) {
      this.computation = t0;
      this.result = t1;
    },
    StreamTransformerBase: function StreamTransformerBase() {
    },
    _MultiStream: function _MultiStream(t0, t1, t2) {
      this.isBroadcast = t0;
      this._onListen = t1;
      this.$ti = t2;
    },
    _MultiStream_listen_closure: function _MultiStream_listen_closure(t0, t1) {
      this.$this = t0;
      this.controller = t1;
    },
    _MultiStreamController: function _MultiStreamController(t0, t1, t2, t3, t4) {
      var _ = this;
      _._varData = null;
      _._state = 0;
      _._doneFuture = null;
      _.onListen = t0;
      _.onPause = t1;
      _.onResume = t2;
      _.onCancel = t3;
      _.$ti = t4;
    },
    HashMap_HashMap$from(other, $K, $V) {
      var result = B.HashMap_HashMap(null, null, null, $K, $V);
      other.forEach$1(0, new A.HashMap_HashMap$from_closure(result, $K, $V));
      return result;
    },
    HashMap_HashMap$from_closure: function HashMap_HashMap$from_closure(t0, t1, t2) {
      this.result = t0;
      this.K = t1;
      this.V = t2;
    },
    _File__exists(namespace, path) {
      throw B.wrapException(B.UnsupportedError$("File._exists"));
    },
    _Namespace__namespace() {
      throw B.wrapException(B.UnsupportedError$("_Namespace"));
    },
    _Namespace__namespacePointer() {
      throw B.wrapException(B.UnsupportedError$("_Namespace"));
    },
    _Platform__operatingSystem() {
      throw B.wrapException(B.UnsupportedError$("Platform._operatingSystem"));
    },
    _checkForErrorResponse(response, message, path) {
      response.$index(0, 0);
      switch (response.$index(0, 0)) {
        case 1:
          throw B.wrapException(B.ArgumentError$(message + ": " + path, null));
        case 2:
          throw B.wrapException(A.FileSystemException_FileSystemException$_fromOSError(new A.OSError(response.$index(0, 2), response.$index(0, 1)), message, path));
        case 3:
          throw B.wrapException(A.FileSystemException$("File closed", path, null));
        default:
          throw B.wrapException(B.AssertionError$("Unknown error"));
      }
    },
    Directory_Directory(path) {
      var t1;
      A.IOOverrides_current();
      B.ArgumentError_checkNotNull(path, "path");
      t1 = A.FileSystemEntity__toNullTerminatedUtf8Array(C.C_Utf8Encoder.convert$1(path));
      return new A._Directory(path, t1);
    },
    File_File(path) {
      var t1;
      A.IOOverrides_current();
      B.ArgumentError_checkNotNull(path, "path");
      t1 = A.FileSystemEntity__toNullTerminatedUtf8Array(C.C_Utf8Encoder.convert$1(path));
      return new A._File(path, t1);
    },
    FileSystemException$(message, path, osError) {
      return new A.FileSystemException(message, path, osError);
    },
    FileSystemException_FileSystemException$_fromOSError(err, message, path) {
      if ($.$get$Platform_isWindows())
        switch (err.errorCode) {
          case 5:
          case 16:
          case 19:
          case 24:
          case 32:
          case 33:
          case 65:
          case 108:
            return new A.PathAccessException(message, path, err);
          case 80:
          case 183:
            return new A.PathExistsException(message, path, err);
          case 2:
          case 3:
          case 15:
          case 123:
          case 18:
          case 53:
          case 67:
          case 161:
          case 206:
            return new A.PathNotFoundException(message, path, err);
          default:
            return new A.FileSystemException(message, path, err);
        }
      else
        switch (err.errorCode) {
          case 1:
          case 13:
            return new A.PathAccessException(message, path, err);
          case 17:
            return new A.PathExistsException(message, path, err);
          case 2:
            return new A.PathNotFoundException(message, path, err);
          default:
            return new A.FileSystemException(message, path, err);
        }
    },
    _File__namespacePointer() {
      return A._Namespace__namespacePointer();
    },
    _File__dispatchWithNamespace(request, data) {
      data[0] = A._File__namespacePointer();
    },
    FileSystemEntity__toNullTerminatedUtf8Array(l) {
      var t2, tmp,
        t1 = l.length;
      if (t1 !== 0)
        t2 = !C.NativeUint8List_methods.get$isEmpty(l) && !J.$eq$(C.NativeUint8List_methods.get$last(l), 0);
      else
        t2 = true;
      if (t2) {
        tmp = new Uint8Array(t1 + 1);
        C.NativeUint8List_methods.setRange$3(tmp, 0, t1, l);
        return tmp;
      } else
        return l;
    },
    IOOverrides_current() {
      $.$get$_ioOverridesToken();
      return null;
    },
    _Platform_operatingSystem() {
      return A._Platform__operatingSystem();
    },
    OSError: function OSError(t0, t1) {
      this.message = t0;
      this.errorCode = t1;
    },
    _Directory: function _Directory(t0, t1) {
      this._io$_path = t0;
      this._rawPath = t1;
    },
    _Directory__delete_closure: function _Directory__delete_closure(t0) {
      this.$this = t0;
    },
    FileMode: function FileMode() {
    },
    FileSystemException: function FileSystemException(t0, t1, t2) {
      this.message = t0;
      this.path = t1;
      this.osError = t2;
    },
    PathAccessException: function PathAccessException(t0, t1, t2) {
      this.message = t0;
      this.path = t1;
      this.osError = t2;
    },
    PathExistsException: function PathExistsException(t0, t1, t2) {
      this.message = t0;
      this.path = t1;
      this.osError = t2;
    },
    PathNotFoundException: function PathNotFoundException(t0, t1, t2) {
      this.message = t0;
      this.path = t1;
      this.osError = t2;
    },
    _File: function _File(t0, t1) {
      this._io$_path = t0;
      this._rawPath = t1;
    },
    _File__delete_closure: function _File__delete_closure(t0) {
      this.$this = t0;
    },
    _File__delete_closure0: function _File__delete_closure0(t0) {
      this.$this = t0;
    },
    _File_length_closure: function _File_length_closure(t0) {
      this.$this = t0;
    },
    FileSystemEntityType: function FileSystemEntityType(t0) {
      this._io$_type = t0;
    },
    FileSystemEntity: function FileSystemEntity() {
    },
    _JSSecureRandom: function _JSSecureRandom(t0) {
      this._math$_buffer = t0;
    },
    Clock: function Clock() {
    },
    RawDynamicCachedFonts_cacheFont(url, cacheStalePeriod, maxCacheObjects) {
      return A.RawDynamicCachedFonts_cacheFont$body(url, cacheStalePeriod, maxCacheObjects);
    },
    RawDynamicCachedFonts_cacheFont$body(url, cacheStalePeriod, maxCacheObjects) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.FileInfo),
        $async$returnValue, t1, cacheKey, font;
      var $async$RawDynamicCachedFonts_cacheFont = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($.WidgetsBinding__instance == null)
                B.WidgetsFlutterBinding$();
              $.WidgetsBinding__instance.toString;
              t1 = B.RegExp_RegExp("[^A-Za-z0-9._-]", true, false);
              cacheKey = B.stringReplaceAllUnchecked(url, t1, "");
              if (cacheStalePeriod._duration !== D.Duration_31536000000000._duration || maxCacheObjects !== 200) {
                t1 = $.$get$DynamicCachedFontsCacheManager__cacheManagers();
                if (t1.$index(0, cacheKey) == null)
                  t1.$indexSet(0, cacheKey, A.CacheManager$(A.Config$(cacheKey, maxCacheObjects, cacheStalePeriod)));
              }
              $async$goto = 3;
              return B._asyncAwait(A.DynamicCachedFontsCacheManager_getCacheManager(cacheKey).downloadFile$2$key(url, cacheKey), $async$RawDynamicCachedFonts_cacheFont);
            case 3:
              // returning from await.
              font = $async$result;
              t1 = font.file;
              if (!$.$get$Utils__fontFileExtensionManager().matchesFileExtension$2(E.ParsedPath_ParsedPath$parse(t1.path, t1.fileSystem._memory_file_system$_context.style).get$basename(), t1.readAsBytesSync$0()))
                B.throwExpression(B.UnsupportedError$("Bad File Format\nThe provided file extension is not supported. Currently, only OpenType (OTF) and TrueType (TTF) fonts are supported."));
              A.devLog(B._setArrayType(["Font file downloaded\n", "Validity: " + font.validTill.toString$0(0), "Download URL: " + font.originalUrl], type$.JSArray_String));
              $async$returnValue = font;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$RawDynamicCachedFonts_cacheFont, $async$completer);
    },
    RawDynamicCachedFonts_loadCachedFamily(urls, fontFamily, fontLoader) {
      return A.RawDynamicCachedFonts_loadCachedFamily$body(urls, fontFamily, fontLoader);
    },
    RawDynamicCachedFonts_loadCachedFamily$body(urls, fontFamily, fontLoader) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.Iterable_FileInfo),
        $async$returnValue, fonts, t1, t2, t3, t4, cacheKey, font, cachedFontBytes, $async$temp1, $async$temp2;
      var $async$RawDynamicCachedFonts_loadCachedFamily = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              fontLoader = new A.FontLoader(fontFamily, B._setArrayType([], type$.JSArray_Future_Uint8List));
              fonts = B._setArrayType([], type$.JSArray_FileInfo);
              if ($.WidgetsBinding__instance == null)
                B.WidgetsFlutterBinding$();
              $.WidgetsBinding__instance.toString;
              t1 = J.get$iterator$ax(urls), t2 = type$._Future_ByteData;
            case 3:
              // for condition
              if (!t1.moveNext$0()) {
                // goto after for
                $async$goto = 4;
                break;
              }
              t3 = t1.get$current();
              t4 = B.RegExp_RegExp("[^A-Za-z0-9._-]", true, false);
              cacheKey = B.stringReplaceAllUnchecked(t3, t4, "");
              t3 = $.$get$DynamicCachedFontsCacheManager__cacheManagers();
              t4 = t3.$index(0, null);
              if (t4 == null)
                t4 = t3.$index(0, cacheKey);
              if (t4 == null) {
                t3 = t3.$index(0, "DynamicCachedFontsFontCacheKey");
                t3.toString;
              } else
                t3 = t4;
              $async$goto = 5;
              return B._asyncAwait(t3._cache_manager$_store.getFile$2$ignoreMemCache(cacheKey, false), $async$RawDynamicCachedFonts_loadCachedFamily);
            case 5:
              // returning from await.
              font = $async$result;
              if (font == null)
                throw B.wrapException(B.StateError$("Font should already be cached to be loaded"));
              fonts.push(font);
              $async$temp1 = J;
              $async$temp2 = C.NativeUint8List_methods;
              $async$goto = 6;
              return B._asyncAwait(font.file.readAsBytes$0(), $async$RawDynamicCachedFonts_loadCachedFamily);
            case 6:
              // returning from await.
              cachedFontBytes = $async$temp1.asByteData$2$x($async$temp2.get$buffer($async$result), 0, null);
              t3 = new B._Future($.Zone__current, t2);
              t3._asyncComplete$1(cachedFontBytes);
              fontLoader.addFont$1(t3);
              // goto for condition
              $async$goto = 3;
              break;
            case 4:
              // after for
              $async$goto = 7;
              return B._asyncAwait(fontLoader.load$0(), $async$RawDynamicCachedFonts_loadCachedFamily);
            case 7:
              // returning from await.
              A.devLog(B._setArrayType(["Font has been loaded!"], type$.JSArray_String));
              $async$returnValue = fonts;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$RawDynamicCachedFonts_loadCachedFamily, $async$completer);
    },
    DynamicCachedFonts: function DynamicCachedFonts(t0, t1, t2) {
      var _ = this;
      _.urls = t0;
      _.fontFamily = t1;
      _.cacheStalePeriod = t2;
      _._loaded = false;
    },
    DynamicCachedFonts_load_closure: function DynamicCachedFonts_load_closure(t0) {
      this.$this = t0;
    },
    DynamicCachedFonts_load_closure0: function DynamicCachedFonts_load_closure0() {
    },
    DynamicCachedFonts_load_closure1: function DynamicCachedFonts_load_closure1(t0) {
      this.$this = t0;
    },
    devLog(messageList) {
    },
    DynamicCachedFontsCacheManager_getCacheManager(cacheKey) {
      var t1 = $.$get$DynamicCachedFontsCacheManager__cacheManagers(),
        t2 = t1.$index(0, null);
      if (t2 == null)
        t2 = t1.$index(0, cacheKey);
      if (t2 == null) {
        t1 = t1.$index(0, "DynamicCachedFontsFontCacheKey");
        t1.toString;
      } else
        t1 = t2;
      return t1;
    },
    _FontFileExtensionManager: function _FontFileExtensionManager(t0) {
      this._validExtensions = t0;
    },
    _FontFileExtensionManager_matchesFileExtension_closure: function _FontFileExtensionManager_matchesFileExtension_closure(t0) {
      this.headerBytes = t0;
    },
    Clock0: function Clock0() {
    },
    _RealtimeClock: function _RealtimeClock() {
    },
    MemoryDirectory: function MemoryDirectory(t0, t1) {
      this.fileSystem = t0;
      this.path = t1;
    },
    MemoryDirectory_createSync_closure: function MemoryDirectory_createSync_closure(t0) {
      this.recursive = t0;
    },
    MemoryDirectory_createTempSync_closure: function MemoryDirectory_createTempSync_closure(t0) {
      this.dirname = t0;
    },
    MemoryDirectory_createTempSync_closure0: function MemoryDirectory_createTempSync_closure0(t0) {
      this.dirname = t0;
    },
    MemoryDirectory_createTempSync_name: function MemoryDirectory_createTempSync_name(t0, t1) {
      this._box_0 = t0;
      this.basename = t1;
    },
    _MemoryDirectory_MemoryFileSystemEntity_DirectoryAddOnsMixin: function _MemoryDirectory_MemoryFileSystemEntity_DirectoryAddOnsMixin() {
    },
    _FileSink__FileSink$fromFile(file, mode, encoding) {
      var e, exception, t2, future, t1 = {},
        node = B._Cell$named("node");
      t1.deferredException = null;
      try {
        node._value = file.get$_resolvedBackingOrCreate();
      } catch (exception) {
        t2 = B.unwrapException(exception);
        if (type$.Exception._is(t2)) {
          e = t2;
          t1.deferredException = e;
        } else
          throw exception;
      }
      future = A.Future_Future$microtask(new A._FileSink__FileSink$fromFile_closure(t1, file, node, mode), type$.FileNode);
      return new A._FileSink(new B._AsyncCompleter(new B._Future($.Zone__current, type$._Future_void), type$._AsyncCompleter_void), future, encoding);
    },
    MemoryFile: function MemoryFile(t0, t1) {
      this.fileSystem = t0;
      this.path = t1;
    },
    MemoryFile__resolvedBackingOrCreate_closure: function MemoryFile__resolvedBackingOrCreate_closure(t0) {
      this.$this = t0;
    },
    MemoryFile__resolvedBackingOrCreate_closure0: function MemoryFile__resolvedBackingOrCreate_closure0(t0) {
      this.$this = t0;
    },
    MemoryFile__doCreate_closure: function MemoryFile__doCreate_closure(t0) {
      this.recursive = t0;
    },
    _FileSink: function _FileSink(t0, t1, t2) {
      var _ = this;
      _._completer = t0;
      _._pendingWrites = t1;
      _._streamCompleter = null;
      _._memory_file$_isClosed = false;
      _.encoding = t2;
    },
    _FileSink__FileSink$fromFile_closure: function _FileSink__FileSink$fromFile_closure(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.file = t1;
      _.node = t2;
      _.mode = t3;
    },
    _FileSink_addStream_closure: function _FileSink_addStream_closure(t0) {
      this.$this = t0;
    },
    _FileSink_addStream_closure1: function _FileSink_addStream_closure1(t0) {
      this.$this = t0;
    },
    _FileSink_addStream_closure0: function _FileSink_addStream_closure0(t0) {
      this.$this = t0;
    },
    _FileSink_close_closure: function _FileSink_close_closure(t0) {
      this.$this = t0;
    },
    _FileSink_close_closure0: function _FileSink_close_closure0(t0) {
      this.$this = t0;
    },
    _FileSink__addData_closure: function _FileSink__addData_closure(t0) {
      this.data = t0;
    },
    MemoryFileStat: function MemoryFileStat(t0, t1) {
      this.type = t0;
      this.size = t1;
    },
    _defaultOpHandle(context, operation) {
    },
    _MemoryFileSystem: function _MemoryFileSystem(t0, t1, t2, t3) {
      var _ = this;
      _._systemTemp = _._memory_file_system$_root = null;
      _._memory_file_system$_context = t0;
      _.opHandle = t1;
      _.clock = t2;
      _.style = t3;
    },
    _MemoryFileSystem_findNode_subpath: function _MemoryFileSystem_findNode_subpath(t0, t1, t2) {
      this.$this = t0;
      this.parts = t1;
      this.i = t2;
    },
    _MemoryFileSystem_findNode_closure: function _MemoryFileSystem_findNode_closure(t0, t1, t2) {
      this.segmentVisitor = t0;
      this.i = t1;
      this.finalSegment = t2;
    },
    MemoryFileSystemEntity: function MemoryFileSystemEntity() {
    },
    MemoryFileSystemEntity_backing_closure: function MemoryFileSystemEntity_backing_closure(t0) {
      this.$this = t0;
    },
    MemoryFileSystemEntity_resolvedBacking_closure: function MemoryFileSystemEntity_resolvedBacking_closure(t0) {
      this.$this = t0;
    },
    MemoryFileSystemEntity_resolvedBacking_closure0: function MemoryFileSystemEntity_resolvedBacking_closure0(t0) {
      this.$this = t0;
    },
    MemoryFileSystemEntity_defaultCheckType_closure: function MemoryFileSystemEntity_defaultCheckType_closure(t0) {
      this.$this = t0;
    },
    MemoryFileSystemEntity_internalCreateSync_closure: function MemoryFileSystemEntity_internalCreateSync_closure(t0) {
      this.createChild = t0;
    },
    DirectoryNode$($parent) {
      var t1 = new A.DirectoryNode(B.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.Node), $parent),
        t2 = $parent == null;
      if (t2)
        t1.get$isRoot();
      if (t2)
        B.throwExpression(D.FileSystemException_LN3);
      t1.RealNode$1($parent);
      return t1;
    },
    Node: function Node() {
    },
    RealNode: function RealNode() {
    },
    DirectoryNode: function DirectoryNode(t0, t1) {
      var _ = this;
      _.children = t0;
      _.__RealNode_accessed_A = _.__RealNode_modified_A = _.__RealNode_changed_A = $;
      _._node$_parent = t1;
    },
    RootNode: function RootNode(t0, t1, t2) {
      var _ = this;
      _.fs = t0;
      _.children = t1;
      _.__RealNode_accessed_A = _.__RealNode_modified_A = _.__RealNode_changed_A = $;
      _._node$_parent = t2;
    },
    FileNode: function FileNode(t0, t1) {
      var _ = this;
      _._content = t0;
      _.__RealNode_accessed_A = _.__RealNode_modified_A = _.__RealNode_changed_A = $;
      _._node$_parent = t1;
    },
    FileSystemOp: function FileSystemOp(t0) {
      this._operations$_value = t0;
    },
    FileSystemStyle: function FileSystemStyle() {
    },
    _Posix: function _Posix() {
    },
    checkIsDir(node, path) {
      var t1 = node.get$type();
      if (t1 !== D.FileSystemEntityType_1)
        throw B.wrapException(A.notADirectory(B._asString(path.call$0())));
    },
    checkType(expectedType, actualType, path) {
      if (expectedType !== actualType)
        switch (expectedType) {
          case D.FileSystemEntityType_1:
            throw B.wrapException(A.notADirectory(B._asString(path.call$0())));
          case D.FileSystemEntityType_0:
            throw B.wrapException(A.isADirectory(B._asString(path.call$0())));
          case D.FileSystemEntityType_2:
            throw B.wrapException(A._fsException(B._asString(path.call$0()), "Invalid argument", A.ErrorCodes_EINVAL()));
          default:
            throw B.wrapException(B.AssertionError$(null));
        }
    },
    isEmpty(str) {
      return str.length === 0;
    },
    resolveLinks(link, path, ledger, tailVisitor) {
      var breadcrumbs = B.LinkedHashSet_LinkedHashSet$_empty(type$.LinkNode),
        node = link;
      while (true) {
        node.get$type();
        if (!false)
          break;
        if (!breadcrumbs.add$1(0, node))
          throw B.wrapException(A._fsException(B._asString(path.call$0()), "Too many levels of symbolic links", A.ErrorCodes_ELOOP()));
        node = node.getReferent$1$tailVisitor(new A.resolveLinks_closure(tailVisitor));
      }
      return node;
    },
    resolveLinks_closure: function resolveLinks_closure(t0) {
      this.tailVisitor = t0;
    },
    noSuchFileOrDirectory(path) {
      var _s25_ = "No such file or directory";
      return new A.FileSystemException(_s25_, path, new A.OSError(_s25_, A.ErrorCodes_ENOENT()));
    },
    notADirectory(path) {
      var _s15_ = "Not a directory";
      return new A.FileSystemException(_s15_, path, new A.OSError(_s15_, A.ErrorCodes_ENOTDIR()));
    },
    isADirectory(path) {
      var _s14_ = "Is a directory";
      return new A.FileSystemException(_s14_, path, new A.OSError(_s14_, A.ErrorCodes_EISDIR()));
    },
    _fsException(path, msg, errorCode) {
      return new A.FileSystemException(msg, path, new A.OSError(msg, errorCode));
    },
    DirectoryAddOnsMixin: function DirectoryAddOnsMixin() {
    },
    ErrorCodes_EINVAL() {
      return A.ErrorCodes__platform(new A.ErrorCodes_EINVAL_closure());
    },
    ErrorCodes_EISDIR() {
      return A.ErrorCodes__platform(new A.ErrorCodes_EISDIR_closure());
    },
    ErrorCodes_ELOOP() {
      return A.ErrorCodes__platform(new A.ErrorCodes_ELOOP_closure());
    },
    ErrorCodes_ENOENT() {
      return A.ErrorCodes__platform(new A.ErrorCodes_ENOENT_closure());
    },
    ErrorCodes_ENOTDIR() {
      return A.ErrorCodes__platform(new A.ErrorCodes_ENOTDIR_closure());
    },
    ErrorCodes_ENOTEMPTY() {
      return A.ErrorCodes__platform(new A.ErrorCodes_ENOTEMPTY_closure());
    },
    ErrorCodes__platform(getCode) {
      return getCode.call$1(D.C__LinuxCodes);
    },
    ErrorCodes_EINVAL_closure: function ErrorCodes_EINVAL_closure() {
    },
    ErrorCodes_EISDIR_closure: function ErrorCodes_EISDIR_closure() {
    },
    ErrorCodes_ELOOP_closure: function ErrorCodes_ELOOP_closure() {
    },
    ErrorCodes_ENOENT_closure: function ErrorCodes_ENOENT_closure() {
    },
    ErrorCodes_ENOTDIR_closure: function ErrorCodes_ENOTDIR_closure() {
    },
    ErrorCodes_ENOTEMPTY_closure: function ErrorCodes_ENOTEMPTY_closure() {
    },
    _LinuxCodes: function _LinuxCodes() {
    },
    FileSystem: function FileSystem() {
    },
    FontLoader: function FontLoader(t0, t1) {
      this.family = t0;
      this._font_loader$_loaded = false;
      this._fontFutures = t1;
    },
    FontLoader_addFont_closure: function FontLoader_addFont_closure() {
    },
    FontLoader_load_closure: function FontLoader_load_closure(t0) {
      this.$this = t0;
    },
    FontLoader_load__closure: function FontLoader_load__closure(t0) {
      this.$this = t0;
    },
    CacheManager$(config) {
      var t1 = A.CacheStore$(config),
        t2 = new A.CacheManager(config, t1),
        t3 = B.ListQueue$(null, type$.QueueItem);
      t2.__CacheManager__webHelper_F = new A.WebHelper(t1, config.fileService, B.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.BehaviorSubject_FileResponse), t3);
      return t2;
    },
    CacheManager: function CacheManager(t0, t1) {
      this._config = t0;
      this._cache_manager$_store = t1;
      this.__CacheManager__webHelper_F = $;
    },
    CacheManager_downloadFile_closure: function CacheManager_downloadFile_closure() {
    },
    CacheStore$(config) {
      var t1 = type$.String,
        t2 = Date.now();
      return new A.CacheStore(B.LinkedHashMap_LinkedHashMap$_empty(t1, type$.Future_nullable_CacheObject), B.LinkedHashMap_LinkedHashMap$_empty(t1, type$.CacheObject), config.fileSystem, config, config.repo.open$0().then$1$1(new A.CacheStore_closure(config), type$.CacheInfoRepository), new B.DateTime(t2, 0, false));
    },
    CacheStore: function CacheStore(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._futureCache = t0;
      _._cache_store$_memCache = t1;
      _.fileSystem = t2;
      _._cache_store$_config = t3;
      _._cacheInfoRepository = t4;
      _.lastCleanupRun = t5;
      _._scheduledCleanup = null;
    },
    CacheStore_closure: function CacheStore_closure(t0) {
      this.config = t0;
    },
    CacheStore_retrieveCacheData_closure: function CacheStore_retrieveCacheData_closure(t0, t1, t2) {
      this.$this = t0;
      this.key = t1;
      this.completer = t2;
    },
    CacheStore__scheduleCleanup_closure: function CacheStore__scheduleCleanup_closure(t0) {
      this.$this = t0;
    },
    Config$(cacheKey, maxNrOfCacheObjects, stalePeriod) {
      var t2, _null = null,
        t1 = $.$get$Style_posix();
      t1 = new A._MemoryFileSystem(new E.Context(t1, "/"), A.memory_file_system___defaultOpHandle$closure(), D.C__RealtimeClock, D.C__Posix);
      t2 = new A.RootNode(t1, B.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.Node), _null);
      t2.get$isRoot();
      t2.RealNode$1(_null);
      t1._memory_file_system$_root = t2;
      t2 = t1._systemTemp;
      t1 = new A.MemoryDirectory(t1, t1.getPath$1(t2 == null ? t1._systemTemp = new A.MemoryDirectory(t1, t1.getPath$1("/")).createTempSync$1(".tmp_").path : t2));
      t1.createSync$0();
      t1 = new A.MemoryCacheSystem(t1.createTemp$1("cache"));
      t2 = E.zoneClient();
      t2 = new E.BrowserClient(new init.G.AbortController());
      t2 = new A.HttpFileService(t2);
      return new A.Config(new A.NonStoringObjectProvider(), t1, stalePeriod, maxNrOfCacheObjects, t2);
    },
    Config: function Config(t0, t1, t2, t3, t4) {
      var _ = this;
      _.repo = t0;
      _.fileSystem = t1;
      _.stalePeriod = t2;
      _.maxNrOfCacheObjects = t3;
      _.fileService = t4;
    },
    CacheLogger: function CacheLogger() {
    },
    DownloadProgress: function DownloadProgress(t0) {
      this.originalUrl = t0;
    },
    FileInfo: function FileInfo(t0, t1, t2) {
      this.file = t0;
      this.validTill = t1;
      this.originalUrl = t2;
    },
    FileResponse: function FileResponse() {
    },
    NonStoringObjectProvider: function NonStoringObjectProvider() {
    },
    CacheObject$(url, eTag, id, key, $length, relativePath, touched, validTill) {
      return new A.CacheObject(id, url, key, relativePath, validTill, eTag, $length, touched);
    },
    CacheObject: function CacheObject(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.id = t0;
      _.url = t1;
      _.key = t2;
      _.relativePath = t3;
      _.validTill = t4;
      _.eTag = t5;
      _.length = t6;
      _.touched = t7;
    },
    MemoryCacheSystem: function MemoryCacheSystem(t0) {
      this.directory = t0;
    },
    FileService: function FileService() {
    },
    HttpFileService: function HttpFileService(t0) {
      this._httpClient = t0;
    },
    HttpGetResponse: function HttpGetResponse(t0, t1) {
      this._receivedTime = t0;
      this._response = t1;
    },
    QueueItem: function QueueItem(t0, t1, t2) {
      this.url = t0;
      this.key = t1;
      this.headers = t2;
    },
    WebHelper: function WebHelper(t0, t1, t2, t3) {
      var _ = this;
      _._store = t0;
      _.fileFetcher = t1;
      _._memCache = t2;
      _._web_helper$_queue = t3;
      _.concurrentCalls = 0;
    },
    WebHelper__manageResponse_closure: function WebHelper__manageResponse_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.oldCacheObject = t2;
    },
    WebHelper__saveFileAndPostUpdates_closure: function WebHelper__saveFileAndPostUpdates_closure(t0, t1) {
      this._box_0 = t0;
      this.receivedBytesResultController = t1;
    },
    HttpExceptionWithStatus: function HttpExceptionWithStatus(t0, t1) {
      this.message = t0;
      this.uri = t1;
    },
    post(url, body, headers) {
      return A._withClient(new A.post_closure(url, headers, body, null), type$.Response);
    },
    _withClient(fn, $T) {
      return A._withClient$body(fn, $T, $T);
    },
    _withClient$body(fn, $T, $async$type) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter($async$type),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], $async$next = [], t1, client;
      var $async$_withClient = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = E.zoneClient();
              client = new E.BrowserClient(new init.G.AbortController());
              $async$handler = 3;
              $async$goto = 6;
              return B._asyncAwait(fn.call$1(client), $async$_withClient);
            case 6:
              // returning from await.
              t1 = $async$result;
              $async$returnValue = t1;
              $async$next = [1];
              // goto finally
              $async$goto = 4;
              break;
              $async$next.push(5);
              // goto finally
              $async$goto = 4;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 4:
              // finally
              $async$handler = 2;
              t1 = client;
              t1._isClosed = true;
              t1._abortController.abort();
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 5:
              // after finally
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return B._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return B._asyncStartSync($async$_withClient, $async$completer);
    },
    post_closure: function post_closure(t0, t1, t2, t3) {
      var _ = this;
      _.url = t0;
      _.headers = t1;
      _.body = t2;
      _.encoding = t3;
    },
    DeferStream$(streamFactory, reusable, $T) {
      return new A.DeferStream(streamFactory, true, $T._eval$1("DeferStream<0>"));
    },
    DeferStream: function DeferStream(t0, t1, t2) {
      this._factory = t0;
      this._isReusable = t1;
      this.$ti = t2;
    },
    BehaviorSubject__deferStream(wrapper, controller, sync, $T) {
      return new A.BehaviorSubject__deferStream_closure(wrapper, controller, $T);
    },
    BehaviorSubject: function BehaviorSubject(t0, t1, t2, t3) {
      var _ = this;
      _._wrapper = t0;
      _._subject$_controller = t1;
      _._isAddingStreamItems = false;
      _._stream = t2;
      _.$ti = t3;
    },
    BehaviorSubject__deferStream_closure: function BehaviorSubject__deferStream_closure(t0, t1, t2) {
      this.wrapper = t0;
      this.controller = t1;
      this.T = t2;
    },
    _Wrapper: function _Wrapper(t0, t1) {
      var _ = this;
      _.isValue = false;
      _.value = t0;
      _.errorAndStackTrace = null;
      _.$ti = t1;
    },
    _BehaviorSubjectStream: function _BehaviorSubjectStream(t0, t1) {
      this._subject = t0;
      this.$ti = t1;
    },
    Subject: function Subject() {
    },
    _SubjectStream: function _SubjectStream(t0, t1) {
      this._subject$_subject = t0;
      this.$ti = t1;
    },
    _StartWithStreamSink: function _StartWithStreamSink(t0, t1) {
      this._startValue = t0;
      this._forwarding_sink$_sink = null;
      this.$ti = t1;
    },
    StartWithStreamTransformer: function StartWithStreamTransformer(t0, t1) {
      this.startValue = t0;
      this.$ti = t1;
    },
    StartWithStreamTransformer_bind_closure: function StartWithStreamTransformer_bind_closure(t0) {
      this.$this = t0;
    },
    _StartWithErrorStreamSink: function _StartWithErrorStreamSink(t0, t1, t2) {
      var _ = this;
      _._e = t0;
      _._st = t1;
      _._forwarding_sink$_sink = null;
      _.$ti = t2;
    },
    StartWithErrorStreamTransformer: function StartWithErrorStreamTransformer(t0, t1, t2) {
      this.error = t0;
      this.stackTrace = t1;
      this.$ti = t2;
    },
    StartWithErrorStreamTransformer_bind_closure: function StartWithErrorStreamTransformer_bind_closure(t0) {
      this.$this = t0;
    },
    _Empty: function _Empty() {
    },
    ErrorAndStackTrace: function ErrorAndStackTrace(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
    },
    ForwardingSink: function ForwardingSink() {
    },
    forwardStream(stream, sinkFactory, $T, $R) {
      var t1;
      if (stream.get$isBroadcast())
        t1 = A._forwardMulti(stream, sinkFactory, $T, $R);
      else
        t1 = A._forward(stream, sinkFactory, $T, $R);
      return t1;
    },
    _forwardMulti(stream, sinkFactory, $T, $R) {
      return new A._MultiStream(true, new A._forwardMulti_closure(sinkFactory, stream, $R), $R._eval$1("_MultiStream<0>"));
    },
    _forward(stream, sinkFactory, $T, $R) {
      var controller, sink, _null = null, t1 = {};
      if (stream.get$isBroadcast())
        controller = new B._SyncBroadcastStreamController(_null, _null, $R._eval$1("_SyncBroadcastStreamController<0>"));
      else
        controller = B.StreamController_StreamController(_null, _null, _null, true, $R);
      t1.subscription = null;
      t1.cancelled = false;
      sink = B._InitializedCell$named("sink", new A._forward_closure(sinkFactory, $T, $R));
      controller.set$onListen(new A._forward_closure0(t1, stream, sink, controller, $R));
      controller.set$onCancel(new A._forward_closure1(t1, sink));
      return controller.get$stream();
    },
    _forwardMulti_closure: function _forwardMulti_closure(t0, t1, t2) {
      this.sinkFactory = t0;
      this.stream = t1;
      this.R = t2;
    },
    _forwardMulti_closure_listenToUpstream: function _forwardMulti_closure_listenToUpstream(t0, t1, t2) {
      this._box_0 = t0;
      this.stream = t1;
      this.sink = t2;
    },
    _forwardMulti__closure: function _forwardMulti__closure(t0, t1) {
      this._box_0 = t0;
      this.sink = t1;
    },
    _forward_closure: function _forward_closure(t0, t1, t2) {
      this.sinkFactory = t0;
      this.T = t1;
      this.R = t2;
    },
    _forward_closure0: function _forward_closure0(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_0 = t0;
      _.stream = t1;
      _.sink = t2;
      _.controller = t3;
      _.R = t4;
    },
    _forward_closure_listenToUpstream: function _forward_closure_listenToUpstream(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.stream = t1;
      _.sink = t2;
      _.controller = t3;
    },
    _forward__listenToUpstream_closure: function _forward__listenToUpstream_closure(t0, t1) {
      this._box_0 = t0;
      this.sink = t1;
    },
    _forward__listenToUpstream_closure0: function _forward__listenToUpstream_closure0(t0, t1) {
      this._box_0 = t0;
      this.sink = t1;
    },
    _forward_closure1: function _forward_closure1(t0, t1) {
      this._box_0 = t0;
      this.sink = t1;
    },
    _MultiControllerSink: function _MultiControllerSink(t0, t1) {
      this.controller = t0;
      this.$ti = t1;
    },
    _EnhancedEventSink: function _EnhancedEventSink(t0, t1) {
      this._forwarding_stream$_controller = t0;
      this.$ti = t1;
    },
    ChapterInfo: function ChapterInfo(t0, t1, t2, t3, t4) {
      var _ = this;
      _.id = t0;
      _.displayName = t1;
      _.filename = t2;
      _.varName = t3;
      _.next = t4;
    },
    Chapter: function Chapter(t0, t1, t2) {
      var _ = this;
      _.info = t0;
      _.lines = t1;
      _.header = null;
      _.ChangeNotifier__count = 0;
      _.ChangeNotifier__listeners = t2;
      _.ChangeNotifier__reentrantlyRemovedListeners = _.ChangeNotifier__notificationCallStackDepth = 0;
    },
    ChapterParser$(debugId, ptr) {
      return new A.ChapterParser(debugId, ptr);
    },
    ChapterParser: function ChapterParser(t0, t1) {
      this.debugId = t0;
      this.ptr = t1;
    },
    FontException$(msg, family) {
      return new A.FontException(msg, family);
    },
    BookCodeException: function BookCodeException(t0) {
      this.msg = t0;
    },
    FontException: function FontException(t0, t1) {
      this.msg = t0;
      this.family = t1;
    },
    FontFile_fromId(id) {
      return A.FontFile_fromId$body(id);
    },
    FontFile_fromId$body(id) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.FontFile),
        $async$returnValue, data, files, family, urls, n, t1, response, t2, t3, t4;
      var $async$FontFile_fromId = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = type$.String;
              $async$goto = 3;
              return B._asyncAwait(A.send("font_post_info", B.LinkedHashMap_LinkedHashMap$_literal(["id", id], t1, type$.dynamic)), $async$FontFile_fromId);
            case 3:
              // returning from await.
              response = $async$result;
              t2 = response.statusCode;
              t3 = response.headers;
              t4 = response.bodyBytes;
              if (t2 !== 200) {
                E.encodingForContentTypeHeader(E._contentTypeForHeaders(t3)).decode$1(t4);
                throw B.wrapException(A.FontException$("Font error code=" + t2 + ": " + response.reasonPhrase, null));
              } else {
                data = C.C_JsonCodec.decode$1(E.encodingForContentTypeHeader(E._contentTypeForHeaders(t3)).decode$1(t4));
                if (data == null)
                  throw B.wrapException(A.FontException$("Null Data from server.", C.JSInt_methods.toString$0(id)));
                B.S(data);
                t2 = J.getInterceptor$asx(data);
                files = t2.$index(data, "file");
                family = t2.$index(data, "family");
                B.S(files);
                if (files == null || family == null)
                  throw B.wrapException(A.FontException$("Null url/family received. family=" + B.S(family) + " url=" + B.S(files), family));
                t2 = J.getInterceptor$ax(files);
                t1 = t2.map$1$1(files, new A.FontFile_fromId_closure(), t1);
                t1 = B.List_List$_of(t1, t1.$ti._eval$1("ListIterable.E"));
                t1.$flags = 1;
                urls = t1;
                for (n = 0; n < t2.get$length(files); ++n)
                  urls[n] = "https://homeworld.nfshost.com//font/" + urls[n];
                $async$returnValue = new A.FontFile(id, urls, family, D._LoadStatus_0, urls.length > 2 ? new A.DynamicCachedFonts(urls, family, D.Duration_2592000000000) : new A.DynamicCachedFonts(B._setArrayType([urls[0]], type$.JSArray_String), family, D.Duration_2592000000000));
                // goto return
                $async$goto = 1;
                break;
              }
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$FontFile_fromId, $async$completer);
    },
    FontCache_intToWeight(value) {
      if (value == null)
        return C.FontWeight_4_500;
      if (value <= 100)
        return C.FontWeight_0_100;
      else if (value <= 200)
        return C.FontWeight_1_200;
      else if (value <= 300)
        return C.FontWeight_2_300;
      else if (value <= 400)
        return C.FontWeight_3_400;
      else if (value <= 500)
        return C.FontWeight_4_500;
      else if (value <= 600)
        return C.FontWeight_5_600;
      else if (value <= 700)
        return C.FontWeight_6_700;
      else if (value <= 800)
        return C.FontWeight_7_800;
      else if (value <= 1000)
        return C.FontWeight_8_900;
      else
        return C.FontWeight_4_500;
    },
    _LoadStatus: function _LoadStatus(t0, t1) {
      this.index = t0;
      this._name = t1;
    },
    FontFile: function FontFile(t0, t1, t2, t3, t4) {
      var _ = this;
      _.id = t0;
      _.urls = t1;
      _.family = t2;
      _._font_cache$_status = t3;
      _.cache = t4;
    },
    FontFile_fromId_closure: function FontFile_fromId_closure() {
    },
    FontCache: function FontCache(t0) {
      this.files = t0;
    },
    FontInterm: function FontInterm(t0, t1, t2, t3, t4) {
      var _ = this;
      _.fileId = t0;
      _.size = t1;
      _.italic = t2;
      _.weight = t3;
      _.color = t4;
      _.file = null;
    },
    Wousi$fromByte(byte) {
      var t1 = new A.Wousi($, $, $, $, $);
      if (byte < 15) {
        t1.__Wousi_weight_F = 500;
        t1.__Wousi_strikethrough_F = t1.__Wousi_underline_F = t1.__Wousi_overline_F = t1.__Wousi_italic_F = false;
      } else {
        t1.__Wousi_italic_F = (byte & 1) > 0;
        t1.__Wousi_strikethrough_F = (byte & 2) > 0;
        t1.__Wousi_underline_F = (byte & 4) > 0;
        t1.__Wousi_overline_F = (byte & 8) > 0;
        t1.__Wousi_weight_F = Math.max(Math.min(C.JSInt_methods._tdivFast$1(byte, 16), 9), 1) * 100;
      }
      return t1;
    },
    Wousi: function Wousi(t0, t1, t2, t3, t4) {
      var _ = this;
      _.__Wousi_weight_F = t0;
      _.__Wousi_italic_F = t1;
      _.__Wousi_underline_F = t2;
      _.__Wousi_overline_F = t3;
      _.__Wousi_strikethrough_F = t4;
    },
    LiveFont: function LiveFont(t0) {
      var _ = this;
      _.tabs = 0;
      _.align = t0;
      _.wousi = _.fontCol = _.bgCol = _.size = _.fontId = null;
    },
    LiveTextHolder: function LiveTextHolder(t0) {
      this.text = "";
      this.font = t0;
    },
    LiveFragment: function LiveFragment(t0) {
      this.text = "";
      this.font = t0;
    },
    LiveSpanOfText: function LiveSpanOfText(t0, t1) {
      this.lines = t0;
      this.align = t1;
      this.tabs = 0;
    },
    _instantiateCodeTag(cls, params) {
      return A._instantiateCodeTag$body(cls, params);
    },
    _instantiateCodeTag$body(cls, params) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.Holder),
        $async$returnValue, iconIndex, t1;
      var $async$_instantiateCodeTag = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = cls === "COPSTING" ? 3 : 5;
              break;
            case 3:
              // then
              $async$returnValue = D.C_HiddenTextElement;
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$goto = cls === "ICON" ? 6 : 7;
              break;
            case 6:
              // then
              iconIndex = B.Primitives_parseInt(params[0], null);
              $async$goto = 8;
              return B._asyncAwait(B.loadDeferredLibrary("misc_code_lib", ""), $async$_instantiateCodeTag);
            case 8:
              // returning from await.
              B.checkDeferredIsLoaded("misc_code_lib");
              t1 = iconIndex == null ? 30 : iconIndex;
              $async$returnValue = G.IconHolder$(t1, C.JSArray_methods.sublist$1(params, 1));
              // goto return
              $async$goto = 1;
              break;
            case 7:
              // join
            case 4:
              // join
              $async$returnValue = new A.UnhandledCodeElement(cls, "CodeTag");
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$_instantiateCodeTag, $async$completer);
    },
    readDoubleParam(params, key) {
      var p = A.readParam(params, key);
      if (p != null) {
        if (B.Primitives_parseDouble(p) == null)
          L.ErrorList_showError(new A.BookCodeException("Failed to read double param: " + p), null);
        return null;
      } else
        return null;
    },
    readParam(params, key) {
      var t1, _i, line;
      for (t1 = params.length, _i = 0; _i < t1; ++_i) {
        line = params[_i];
        if (C.JSString_methods.startsWith$1(line, key)) {
          line = C.JSString_methods.trimLeft$0(C.JSString_methods.substring$1(line, key.length));
          return C.JSString_methods.trimLeft$0(C.JSString_methods.startsWith$1(line, "=") ? C.JSString_methods.substring$1(line, 1) : line);
        }
      }
      return null;
    },
    readBool(params, key) {
      var bs = A.readParam(params, key);
      if (bs === "1")
        return true;
      else if (bs === "0")
        return false;
      return null;
    },
    stripKnownParams(params) {
      var map, _i, param, cmp,
        t1 = params.length,
        t2 = type$.String;
      if (t1 === 0)
        return B.LinkedHashMap_LinkedHashMap$_empty(t2, t2);
      else {
        map = B.LinkedHashMap_LinkedHashMap$_empty(t2, t2);
        for (_i = 0; _i < params.length; params.length === t1 || (0, B.throwConcurrentModificationError)(params), ++_i) {
          param = C.JSString_methods.trim$0(params[_i]);
          cmp = param.toLowerCase();
          if (C.JSString_methods.startsWith$1(cmp, "link="))
            map.$indexSet(0, "Link", C.JSString_methods.substring$1(param, 5));
          else if (C.JSString_methods.startsWith$1(cmp, "color="))
            map.$indexSet(0, "Color", C.JSString_methods.substring$1(param, 6));
        }
        return map;
      }
    },
    _instantiateCodeBlock(cls, params, spans) {
      return A._instantiateCodeBlock$body(cls, params, spans);
    },
    _instantiateCodeBlock$body(cls, params, spans) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.Holder),
        $async$returnValue, width, height, bg, t1, link, knownParams;
      var $async$_instantiateCodeBlock = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              knownParams = A.stripKnownParams(params);
              $async$goto = cls === "Art" ? 3 : 5;
              break;
            case 3:
              // then
              $async$goto = 6;
              return B._asyncAwait(B.loadDeferredLibrary("misc_code_lib", ""), $async$_instantiateCodeBlock);
            case 6:
              // returning from await.
              B.checkDeferredIsLoaded("misc_code_lib");
              $async$returnValue = G.ArtHolder$(spans);
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$goto = cls === "SHIRT" ? 7 : 9;
              break;
            case 7:
              // then
              $async$goto = 10;
              return B._asyncAwait(B.loadDeferredLibrary("shirts_lib", ""), $async$_instantiateCodeBlock);
            case 10:
              // returning from await.
              width = A.readDoubleParam(params, "width");
              height = A.readDoubleParam(params, "width");
              B.checkDeferredIsLoaded("shirts_lib");
              $async$returnValue = K.Shirt$(height, spans, width);
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 8;
              break;
            case 9:
              // else
              $async$goto = cls === "BUMPERSTICKER" ? 11 : 13;
              break;
            case 11:
              // then
              $async$goto = 14;
              return B._asyncAwait(B.loadDeferredLibrary("shirts_lib", ""), $async$_instantiateCodeBlock);
            case 14:
              // returning from await.
              width = A.readDoubleParam(params, "width");
              height = A.readDoubleParam(params, "width");
              B.checkDeferredIsLoaded("shirts_lib");
              $async$returnValue = K.BumperSticker$(height, spans, width);
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 12;
              break;
            case 13:
              // else
              $async$goto = cls === "TWEET" ? 15 : 17;
              break;
            case 15:
              // then
              $async$goto = 18;
              return B._asyncAwait(B.loadDeferredLibrary("tweet_lib", ""), $async$_instantiateCodeBlock);
            case 18:
              // returning from await.
              B.checkDeferredIsLoaded("tweet_lib");
              $async$returnValue = O.TweetHolder$(spans);
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 16;
              break;
            case 17:
              // else
              $async$goto = cls === "SIGN" ? 19 : 21;
              break;
            case 19:
              // then
              $async$goto = 22;
              return B._asyncAwait(B.loadDeferredLibrary("misc_code_lib", ""), $async$_instantiateCodeBlock);
            case 22:
              // returning from await.
              B.checkDeferredIsLoaded("misc_code_lib");
              $async$returnValue = G.Sign$(spans);
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 20;
              break;
            case 21:
              // else
              $async$goto = cls === "BG" ? 23 : 25;
              break;
            case 23:
              // then
              bg = params.length !== 0 ? params[0] : null;
              $async$goto = 26;
              return B._asyncAwait(B.loadDeferredLibrary("misc_code_lib", ""), $async$_instantiateCodeBlock);
            case 26:
              // returning from await.
              B.checkDeferredIsLoaded("misc_code_lib");
              $async$returnValue = G.BGCodeElement_fromString(bg, spans);
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 24;
              break;
            case 25:
              // else
              $async$goto = cls === "TICKET" ? 27 : 29;
              break;
            case 27:
              // then
              $async$goto = 30;
              return B._asyncAwait(B.loadDeferredLibrary("misc_code_lib", ""), $async$_instantiateCodeBlock);
            case 30:
              // returning from await.
              B.checkDeferredIsLoaded("misc_code_lib");
              $async$returnValue = G.Ticket$(spans);
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 28;
              break;
            case 29:
              // else
              $async$goto = cls === "POLLSCREEN" ? 31 : 33;
              break;
            case 31:
              // then
              $async$goto = 34;
              return B._asyncAwait(B.loadDeferredLibrary("misc_code_lib", ""), $async$_instantiateCodeBlock);
            case 34:
              // returning from await.
              B.checkDeferredIsLoaded("misc_code_lib");
              $async$returnValue = G.PollScreen$(spans);
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 32;
              break;
            case 33:
              // else
              $async$goto = cls === "AD" ? 35 : 37;
              break;
            case 35:
              // then
              $async$goto = 38;
              return B._asyncAwait(B.loadDeferredLibrary("human_jacks_lib", ""), $async$_instantiateCodeBlock);
            case 38:
              // returning from await.
              B.checkDeferredIsLoaded("human_jacks_lib");
              $async$returnValue = S.HumanJackAdHolder$random();
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 36;
              break;
            case 37:
              // else
              $async$goto = cls === "TITLE" ? 39 : 41;
              break;
            case 39:
              // then
              $async$goto = 42;
              return B._asyncAwait(B.loadDeferredLibrary("title_lib", ""), $async$_instantiateCodeBlock);
            case 42:
              // returning from await.
              B.checkDeferredIsLoaded("title_lib");
              $async$returnValue = new T.TitleHolder();
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 40;
              break;
            case 41:
              // else
              $async$goto = cls === "FULLBGAD" ? 43 : 45;
              break;
            case 43:
              // then
              $async$goto = 46;
              return B._asyncAwait(B.loadDeferredLibrary("ad_widget_lib", ""), $async$_instantiateCodeBlock);
            case 46:
              // returning from await.
              B.checkDeferredIsLoaded("ad_widget_lib");
              $async$returnValue = U.AdElementHolder$(null, spans);
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 44;
              break;
            case 45:
              // else
              $async$goto = cls === "BALLOT" ? 47 : 49;
              break;
            case 47:
              // then
              t1 = A.readBool(params, "extra");
              $async$goto = 50;
              return B._asyncAwait(B.loadDeferredLibrary("ballot_screen_lib", ""), $async$_instantiateCodeBlock);
            case 50:
              // returning from await.
              B.checkDeferredIsLoaded("ballot_screen_lib");
              $async$returnValue = V.BallotHolder$(t1 === true);
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 48;
              break;
            case 49:
              // else
              $async$goto = cls === "GOTOBUTTON" ? 51 : 53;
              break;
            case 51:
              // then
              link = params.length !== 0 ? params[0] : null;
              t1 = A.readBool(params, "IsChapter");
              B.S(params);
              $async$goto = 54;
              return B._asyncAwait(B.loadDeferredLibrary("goto_button_lib", ""), $async$_instantiateCodeBlock);
            case 54:
              // returning from await.
              B.checkDeferredIsLoaded("goto_button_lib");
              $async$returnValue = W.GotoButtonHolder$(t1 !== false, link, spans);
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 52;
              break;
            case 53:
              // else
              $async$goto = cls === "CHARACTERSELECTIONSCREEN" ? 55 : 57;
              break;
            case 55:
              // then
              $async$goto = 58;
              return B._asyncAwait(B.loadDeferredLibrary("character_selection_lib", ""), $async$_instantiateCodeBlock);
            case 58:
              // returning from await.
              B.checkDeferredIsLoaded("character_selection_lib");
              $async$returnValue = new X.CharacterSelectionHolder();
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 56;
              break;
            case 57:
              // else
              $async$goto = cls === "FLATEARTHANDYTHUMBNAIL" ? 59 : 61;
              break;
            case 59:
              // then
              link = knownParams.$index(0, "Link");
              $async$goto = 62;
              return B._asyncAwait(B.loadDeferredLibrary("andy_thumbnail_lib", ""), $async$_instantiateCodeBlock);
            case 62:
              // returning from await.
              B.checkDeferredIsLoaded("andy_thumbnail_lib");
              $async$returnValue = Y.AndyThumbnailHolder$(link, spans);
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 60;
              break;
            case 61:
              // else
              $async$returnValue = new A.UnhandledSpanHoldingCode(cls, spans);
              // goto return
              $async$goto = 1;
              break;
            case 60:
              // join
            case 56:
              // join
            case 52:
              // join
            case 48:
              // join
            case 44:
              // join
            case 40:
              // join
            case 36:
              // join
            case 32:
              // join
            case 28:
              // join
            case 24:
              // join
            case 20:
              // join
            case 16:
              // join
            case 12:
              // join
            case 8:
              // join
            case 4:
              // join
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$_instantiateCodeBlock, $async$completer);
    },
    _parseParsedBlock(cls, params, bin) {
      return A._parseParsedBlock$body(cls, params, bin);
    },
    _parseParsedBlock$body(cls, params, bin) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.Holder),
        $async$returnValue;
      var $async$_parseParsedBlock = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = cls === "COLUMNS" ? 3 : 5;
              break;
            case 3:
              // then
              $async$goto = 6;
              return B._asyncAwait(B.loadDeferredLibrary("misc_code_lib", ""), $async$_parseParsedBlock);
            case 6:
              // returning from await.
              B.checkDeferredIsLoaded("misc_code_lib");
              $async$returnValue = G.Columns_parse(bin);
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$goto = cls === "SIGNCOLUMNS" ? 7 : 8;
              break;
            case 7:
              // then
              $async$goto = 9;
              return B._asyncAwait(B.loadDeferredLibrary("misc_code_lib", ""), $async$_parseParsedBlock);
            case 9:
              // returning from await.
              B.checkDeferredIsLoaded("misc_code_lib");
              $async$returnValue = G.Sign2Cols_parse(bin);
              // goto return
              $async$goto = 1;
              break;
            case 8:
              // join
            case 4:
              // join
              $async$returnValue = new A.UnhandledCodeElement(cls, "ParsedBlock");
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$_parseParsedBlock, $async$completer);
    },
    CodeElementType: function CodeElementType(t0, t1) {
      this.index = t0;
      this._name = t1;
    },
    UnhandledCodeElement: function UnhandledCodeElement(t0, t1) {
      this.classname = t0;
      this.category = t1;
    },
    FutureHolder: function FutureHolder(t0) {
      this.holder = t0;
    },
    NewlineElement: function NewlineElement(t0) {
      this.height = t0;
    },
    ColoredBoxHolder: function ColoredBoxHolder(t0, t1, t2) {
      this.width = t0;
      this.height = t1;
      this.color = t2;
    },
    ColoredBoxFrag: function ColoredBoxFrag(t0, t1, t2) {
      this.width = t0;
      this.height = t1;
      this.color = t2;
    },
    PageBreakOfText: function PageBreakOfText() {
    },
    SpanOfText: function SpanOfText(t0, t1, t2) {
      this.spans = t0;
      this.align = t1;
      this.tabs = t2;
    },
    FragOfText: function FragOfText() {
    },
    FragBody: function FragBody(t0) {
      this.text = t0;
    },
    FragCustom: function FragCustom(t0, t1) {
      this.font = t0;
      this.text = t1;
    },
    UnhandledSpanHoldingCode: function UnhandledSpanHoldingCode(t0, t1) {
      this.clsname = t0;
      this.spans = t1;
    },
    textAlignToHoriz(align) {
      switch (align.index) {
        case 0:
        case 4:
        case 3:
          return C.Alignment_m1_m1;
        case 2:
          return C.Alignment_0_m1;
        case 1:
        case 5:
          return R.Alignment_1_m1;
      }
    },
    wrapInTabs(tabs, align, child) {
      var t1, _null = null,
        horizAlign = A.textAlignToHoriz(align),
        alignWrap = horizAlign.$eq(0, C.Alignment_m1_m1) ? child : new B.Align(horizAlign, _null, _null, child, _null);
      if (tabs === 0)
        return alignWrap;
      else {
        t1 = 15 + 50 * tabs;
        return new B.Padding(new B.EdgeInsets(t1, 0, t1, 0), alignWrap, _null);
      }
    },
    TextHolder: function TextHolder() {
    },
    BodyTextElement: function BodyTextElement(t0) {
      this.text = t0;
    },
    FontWanterTextHolder: function FontWanterTextHolder() {
    },
    AlignedBodyText: function AlignedBodyText(t0, t1, t2) {
      this.align = t0;
      this.tabs = t1;
      this.text = t2;
    },
    HeaderOfText: function HeaderOfText(t0) {
      this.text = t0;
    },
    HiddenTextElement: function HiddenTextElement() {
    },
    CustomFontText: function CustomFontText(t0, t1, t2, t3) {
      var _ = this;
      _.align = t0;
      _.tabs = t1;
      _.font = t2;
      _.text = t3;
    },
    HiliteFontText: function HiliteFontText(t0, t1, t2, t3, t4) {
      var _ = this;
      _.align = t0;
      _.color = t1;
      _.tabs = t2;
      _.font = t3;
      _.text = t4;
    },
    CustomHeaderOfText: function CustomHeaderOfText(t0, t1, t2) {
      this.align = t0;
      this.font = t1;
      this.text = t2;
    },
    RNG: function RNG() {
    },
    CryptoRNG: function CryptoRNG() {
    },
    Uuid: function Uuid() {
    },
    UuidV1: function UuidV1(t0) {
      this.goptions = t0;
    },
    loadFontFromList(list, fontFamily) {
      return A.loadFontFromList$body(list, fontFamily);
    },
    loadFontFromList$body(list, fontFamily) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.void);
      var $async$loadFontFromList = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return B._asyncAwait($.$get$_renderer().get$_fontCollection().loadFontFromList$2$fontFamily(list, fontFamily), $async$loadFontFromList);
            case 2:
              // returning from await.
              B.sendFontChangeMessage();
              // implicit return
              return B._asyncReturn(null, $async$completer);
          }
      });
      return B._asyncStartSync($async$loadFontFromList, $async$completer);
    },
    systemTime() {
      return new B.DateTime(Date.now(), 0, false);
    },
    clock() {
      $.$get$_clockKey();
      return D.C_Clock;
    },
    waitTwoFutures(f1, f2) {
      var t1;
      if (f1 == null)
        t1 = f2;
      else
        t1 = f1;
      return t1;
    },
    stringToAlign(c) {
      if (c === "l")
        return C.TextAlign_0;
      else if (c === "r")
        return C.TextAlign_1;
      else if (c === "c")
        return C.TextAlign_2;
      else if (c === "j")
        return C.TextAlign_3;
      else
        throw B.wrapException(F.ChapterFormatException$("Incorrect align character " + c, "[?]"));
    },
    send(endpoint, body) {
      return A.send$body(endpoint, body);
    },
    send$body(endpoint, body) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.Response),
        $async$returnValue, t1, t2, t3;
      var $async$send = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (C.JSString_methods.startsWith$1(endpoint, "/"))
                endpoint = C.JSString_methods.substring$1(endpoint, 1);
              t1 = B.Uri_parse("https://homeworld.nfshost.com//" + (C.JSString_methods.endsWith$1(endpoint, "/") ? C.JSString_methods.substring$2(endpoint, 0, endpoint.length - 1) : endpoint) + "/");
              t2 = type$.String;
              t2 = B.LinkedHashMap_LinkedHashMap$_literal(["Accept", "application/json", "Access-Control-Allow-Origin", "*"], t2, t2);
              t3 = C.C_JsonCodec.encode$1(body);
              $async$returnValue = A.post(t1, t3, t2);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$send, $async$completer);
    }
  },
  D, E, L, Z, I, M;
  J = holdersList[1];
  B = holdersList[0];
  C = holdersList[2];
  N = holdersList[52];
  K = holdersList[21];
  O = holdersList[23];
  P = holdersList[44];
  Q = holdersList[73];
  R = holdersList[72];
  S = holdersList[24];
  G = holdersList[20];
  T = holdersList[22];
  U = holdersList[16];
  V = holdersList[17];
  W = holdersList[19];
  X = holdersList[18];
  Y = holdersList[25];
  F = holdersList[45];
  H = holdersList[98];
  A = hunkHelpers.updateHolder(holdersList[37], A);
  D = holdersList[106];
  E = holdersList[43];
  L = holdersList[49];
  Z = holdersList[83];
  I = holdersList[88];
  M = holdersList[48];
  A.HttpException.prototype = {
    toString$0(_) {
      var t1 = "" + "HttpException: " + this.message,
        uri = this.uri;
      if (uri != null)
        t1 += ", uri = " + uri.toString$0(0);
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $isException: 1
  };
  A._HeaderValue.prototype = {
    _HeaderValue$2(_value, parameters) {
      var t1 = parameters.get$isNotEmpty(parameters);
      if (t1)
        this._parameters = A.HashMap_HashMap$from(parameters, type$.String, type$.nullable_String);
    },
    toString$0(_) {
      var parameters, t1,
        sb = new B.StringBuffer("");
      sb._contents = "" + this.__http$_value;
      parameters = this._parameters;
      if (parameters != null && parameters.get$isNotEmpty(parameters))
        parameters.forEach$1(0, new A._HeaderValue_toString_closure(sb));
      t1 = sb._contents;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _parse$4(s, parameterSeparator, valueSeparator, preserveBackslash) {
      var t2, t3, t4, t5, t1 = {};
      t1.index = 0;
      t2 = new A._HeaderValue__parse_done(t1, s);
      t3 = new A._HeaderValue__parse_skipWS(t1, t2, s);
      t4 = new A._HeaderValue__parse_parseValue(t1, t2, s, valueSeparator, parameterSeparator);
      t5 = new A._HeaderValue__parse_maybeExpect(t1, t2, s);
      t3.call$0();
      this.__http$_value = t4.call$0();
      t3.call$0();
      if (t2.call$0())
        return;
      t5.call$1(parameterSeparator);
      new A._HeaderValue__parse_parseParameters(t1, this, t2, s, parameterSeparator, valueSeparator, false, t4, t3, t5, new A._HeaderValue__parse_expect(t1, t2, s)).call$0();
    }
  };
  A._ContentType.prototype = {};
  A.StreamTransformerBase.prototype = {};
  A._MultiStream.prototype = {
    listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError) {
      var _null = null,
        controller = new A._MultiStreamController(_null, _null, _null, _null, this.$ti._eval$1("_MultiStreamController<1>"));
      controller.onListen = new A._MultiStream_listen_closure(this, controller);
      return controller._subscribe$4(onData, onError, onDone, cancelOnError === true);
    },
    listen$3$onDone$onError(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    get$isBroadcast() {
      return this.isBroadcast;
    }
  };
  A._MultiStreamController.prototype = {
    addSync$1(data) {
      var t1 = this._state;
      if (t1 >= 4)
        throw B.wrapException(this._badEventState$0());
      if ((t1 & 1) !== 0)
        this.get$_subscription()._add$1(data);
    },
    addErrorSync$2(error, stackTrace) {
      var t1 = this._state;
      if (t1 >= 4)
        throw B.wrapException(this._badEventState$0());
      if ((t1 & 1) !== 0) {
        t1 = this.get$_subscription();
        t1._addError$2(error, stackTrace == null ? C.C__StringStackTrace : stackTrace);
      }
    },
    closeSync$0() {
      var _this = this,
        t1 = _this._state;
      if ((t1 & 4) !== 0)
        return;
      if (t1 >= 4)
        throw B.wrapException(_this._badEventState$0());
      t1 |= 4;
      _this._state = t1;
      if ((t1 & 1) !== 0)
        _this.get$_subscription()._close$0();
    },
    get$stream() {
      throw B.wrapException(B.UnsupportedError$("Not available"));
    },
    $isMultiStreamController: 1
  };
  A.OSError.prototype = {
    toString$0(_) {
      var t1 = "" + "OS Error",
        t2 = this.message;
      if (t2.length !== 0) {
        t1 = t1 + ": " + t2;
        t2 = this.errorCode;
        if (t2 !== -1)
          t1 = t1 + ", errno = " + C.JSInt_methods.toString$0(t2);
      } else {
        t2 = this.errorCode;
        if (t2 !== -1)
          t1 = t1 + ": errno = " + C.JSInt_methods.toString$0(t2);
      }
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    $isException: 1
  };
  A._Directory.prototype = {
    _delete$1$recursive(recursive) {
      return A._File__dispatchWithNamespace(36, [null, this._rawPath, recursive]).then$1$1(new A._Directory__delete_closure(this), type$.Directory);
    },
    toString$0(_) {
      return "Directory: '" + this._io$_path + "'";
    },
    $isDirectory: 1
  };
  A.FileMode.prototype = {};
  A.FileSystemException.prototype = {
    _toStringHelper$1(className) {
      var _this = this,
        t1 = "" + className,
        t2 = _this.message;
      if (t2.length !== 0) {
        t1 = t1 + (": " + t2) + (", path = '" + _this.path + "'");
        t2 = _this.osError;
        if (t2 != null)
          t1 += " (" + t2.toString$0(0) + ")";
      } else {
        t2 = _this.osError;
        if (t2 != null)
          t1 = t1 + (": " + t2.toString$0(0)) + (", path = '" + _this.path + "'");
        else
          t1 += ": " + _this.path;
      }
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    toString$0(_) {
      return this._toStringHelper$1("FileSystemException");
    },
    $isException: 1
  };
  A.PathAccessException.prototype = {
    toString$0(_) {
      return this._toStringHelper$1("PathAccessException");
    }
  };
  A.PathExistsException.prototype = {
    toString$0(_) {
      return this._toStringHelper$1("PathExistsException");
    }
  };
  A.PathNotFoundException.prototype = {
    toString$0(_) {
      return this._toStringHelper$1("PathNotFoundException");
    }
  };
  A._File.prototype = {
    existsSync$0() {
      A._File__exists(A._Namespace__namespace(), this._rawPath);
    },
    _delete$1$recursive(recursive) {
      var _this = this;
      if (recursive)
        return A.Directory_Directory(_this._io$_path).delete$1$recursive(true).then$1$1(new A._File__delete_closure(_this), type$.File);
      return A._File__dispatchWithNamespace(2, [null, _this._rawPath]).then$1$1(new A._File__delete_closure0(_this), type$.File);
    },
    length$0(_) {
      return A._File__dispatchWithNamespace(12, [null, this._rawPath]).then$1$1(new A._File_length_closure(this), type$.int);
    },
    toString$0(_) {
      return "File: '" + this._io$_path + "'";
    },
    $isFile: 1
  };
  A.FileSystemEntityType.prototype = {
    toString$0(_) {
      return D.List_V5i[this._io$_type];
    }
  };
  A.FileSystemEntity.prototype = {
    delete$1$recursive(recursive) {
      return this._delete$1$recursive(recursive);
    },
    delete$0() {
      return this.delete$1$recursive(false);
    }
  };
  A._JSSecureRandom.prototype = {
    _JSSecureRandom$0() {
      var $crypto = self.crypto;
      if ($crypto != null)
        if ($crypto.getRandomValues != null)
          return;
      throw B.wrapException(B.UnsupportedError$("No source of cryptographically secure random numbers available."));
    },
    nextInt$1(max) {
      var byteCount, t1, start, randomLimit, t2, t3, random, result;
      if (max <= 0 || max > 4294967296)
        throw B.wrapException(B.RangeError$("max must be in range 0 < max \u2264 2^32, was " + max));
      if (max > 255)
        if (max > 65535)
          byteCount = max > 16777215 ? 4 : 3;
        else
          byteCount = 2;
      else
        byteCount = 1;
      t1 = this._math$_buffer;
      t1.$flags & 2 && B.throwUnsupportedOperation(t1, 11);
      t1.setUint32(0, 0, false);
      start = 4 - byteCount;
      randomLimit = B._asInt(Math.pow(256, byteCount));
      for (t2 = max - 1, t3 = (max & t2) >>> 0 === 0; true;) {
        crypto.getRandomValues(J.asUint8List$2$x(C.NativeByteData_methods.get$buffer(t1), start, byteCount));
        random = t1.getUint32(0, false);
        if (t3)
          return (random & t2) >>> 0;
        result = random % max;
        if (random - result + max < randomLimit)
          return result;
      }
    }
  };
  A.Clock.prototype = {};
  A.DynamicCachedFonts.prototype = {
    load$0() {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.Iterable_FileInfo),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], $async$self = this, downloadUrls, fontFiles, url, t1, exception, t2, $async$exception;
      var $async$load$0 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self._loaded)
                throw B.wrapException(B.StateError$("Font has already been loaded"));
              $async$self._loaded = true;
              if ($.WidgetsBinding__instance == null)
                B.WidgetsFlutterBinding$();
              $.WidgetsBinding__instance.toString;
              t1 = $async$self.urls;
              $async$goto = 3;
              return B._asyncAwait(B.Future_wait(new B.MappedListIterable(t1, new A.DynamicCachedFonts_load_closure($async$self), B._arrayInstanceType(t1)._eval$1("MappedListIterable<1,Future<String>>")), type$.String), $async$load$0);
            case 3:
              // returning from await.
              downloadUrls = $async$result;
              fontFiles = null;
              $async$handler = 5;
              $async$goto = 8;
              return B._asyncAwait(A.RawDynamicCachedFonts_loadCachedFamily(downloadUrls, $async$self.fontFamily, null), $async$load$0);
            case 8:
              // returning from await.
              fontFiles = $async$result;
              J.where$1$ax(fontFiles, new A.DynamicCachedFonts_load_closure0()).forEach$1(0, new A.DynamicCachedFonts_load_closure1($async$self));
              $async$handler = 2;
              // goto after finally
              $async$goto = 7;
              break;
            case 5:
              // catch
              $async$handler = 4;
              $async$exception = $async$errorStack.pop();
              A.devLog(B._setArrayType(["Font is not in cache.", "Loading font now..."], type$.JSArray_String));
              t1 = J.get$iterator$ax(downloadUrls), t2 = $async$self.cacheStalePeriod;
            case 9:
              // for condition
              if (!t1.moveNext$0()) {
                // goto after for
                $async$goto = 10;
                break;
              }
              url = t1.get$current();
              $async$goto = 11;
              return B._asyncAwait(A.RawDynamicCachedFonts_cacheFont(url, t2, 200), $async$load$0);
            case 11:
              // returning from await.
              // goto for condition
              $async$goto = 9;
              break;
            case 10:
              // after for
              $async$goto = 12;
              return B._asyncAwait(A.RawDynamicCachedFonts_loadCachedFamily(downloadUrls, $async$self.fontFamily, null), $async$load$0);
            case 12:
              // returning from await.
              fontFiles = $async$result;
              // goto after finally
              $async$goto = 7;
              break;
            case 4:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 7:
              // after finally
              $async$returnValue = fontFiles;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return B._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return B._asyncStartSync($async$load$0, $async$completer);
    }
  };
  A._FontFileExtensionManager.prototype = {
    addExtension$2$extension$magicNumber(extension, magicNumber) {
      this._validExtensions.$indexSet(0, extension, magicNumber);
    },
    matchesFileExtension$2(path, fileBytes) {
      var index = C.JSString_methods.lastIndexOf$1(path, "."),
        t1 = C.JSString_methods.substring$1(path, index + 1),
        headerBytes = C.NativeUint8List_methods.toList$0(C.NativeUint8List_methods.sublist$2(fileBytes, 0, 5)),
        t2 = this._validExtensions;
      return t2.containsKey$1(t1.toLowerCase()) || new B.LinkedHashMapValuesIterable(t2, B._instanceType(t2)._eval$1("LinkedHashMapValuesIterable<2>")).any$1(0, new A._FontFileExtensionManager_matchesFileExtension_closure(headerBytes));
    }
  };
  A.Clock0.prototype = {};
  A._RealtimeClock.prototype = {};
  A.MemoryDirectory.prototype = {
    get$expectedType() {
      return D.FileSystemEntityType_1;
    },
    existsSync$0() {
      this.fileSystem.opHandle.call$2(this.path, D.FileSystemOp_6);
      var t1 = this.get$backingOrNull();
      return (t1 == null ? null : t1.get$stat().type) === D.FileSystemEntityType_1;
    },
    createSync$0() {
      var node,
        t1 = this.path;
      this.fileSystem.opHandle.call$2(t1, D.FileSystemOp_3);
      node = this.internalCreateSync$3$createChild$followTailLink$visitLinks(new A.MemoryDirectory_createSync_closure(false), true, true);
      if ((node == null ? null : node.get$type()) !== D.FileSystemEntityType_1)
        throw B.wrapException(A.notADirectory(t1));
    },
    createTemp$1(prefix) {
      return this.createTemp$body$MemoryDirectory(prefix);
    },
    createTemp$body$MemoryDirectory(prefix) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.Directory_2),
        $async$returnValue, $async$self = this;
      var $async$createTemp$1 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $async$self.createTempSync$1(prefix);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$createTemp$1, $async$completer);
    },
    createTempSync$1(prefix) {
      var t3, tempCounter, $name, tempDir, _box_0 = {},
        t1 = this.fileSystem,
        t2 = t1._memory_file_system$_context,
        fullPath = t2.join$2(0, this.path, prefix + "rand"),
        dirname = t2.dirname$1(fullPath),
        basename = E.ParsedPath_ParsedPath$parse(fullPath, t2.style).get$basename(),
        node = type$.nullable_DirectoryNode._as(t1.findNode$1(dirname));
      if (node == null)
        B.throwExpression(A.noSuchFileOrDirectory(B._asString(new A.MemoryDirectory_createTempSync_closure(dirname).call$0())));
      A.checkIsDir(node, new A.MemoryDirectory_createTempSync_closure0(dirname));
      t3 = $.$get$_systemTempCounter();
      B.Expando__checkType(t1);
      tempCounter = t3._jsWeakMap.get(t1);
      _box_0.tempCounter = tempCounter == null ? 0 : tempCounter;
      $name = new A.MemoryDirectory_createTempSync_name(_box_0, basename);
      for (t3 = node.children; t3.containsKey$1($name.call$0());)
        ++_box_0.tempCounter;
      $.$get$_systemTempCounter().$indexSet(0, t1, _box_0.tempCounter);
      tempDir = A.DirectoryNode$(node);
      t3.$indexSet(0, $name.call$0(), tempDir);
      t1 = new A.MemoryDirectory(t1, t2.join$2(0, dirname, $name.call$0()));
      t1.createSync$0();
      return t1;
    },
    toString$0(_) {
      return "MemoryDirectory: '" + this.path + "'";
    },
    $isDirectory: 1,
    $isDirectory0: 1
  };
  A._MemoryDirectory_MemoryFileSystemEntity_DirectoryAddOnsMixin.prototype = {};
  A.MemoryFile.prototype = {
    get$_resolvedBackingOrCreate() {
      var t1, _this = this,
        node = _this.get$backingOrNull();
      if (node == null)
        node = _this._doCreate$0();
      else {
        t1 = node.get$type();
        if (t1 === D.FileSystemEntityType_2)
          node = A.resolveLinks(type$.LinkNode._as(node), new A.MemoryFile__resolvedBackingOrCreate_closure(_this), null, null);
        A.checkType(D.FileSystemEntityType_0, node.get$type(), new A.MemoryFile__resolvedBackingOrCreate_closure0(_this));
      }
      return type$.FileNode._as(node);
    },
    get$expectedType() {
      return D.FileSystemEntityType_0;
    },
    existsSync$0() {
      this.fileSystem.opHandle.call$2(this.path, D.FileSystemOp_6);
      var t1 = this.get$backingOrNull();
      return (t1 == null ? null : t1.get$stat().type) === D.FileSystemEntityType_0;
    },
    _doCreate$0() {
      var node = this.internalCreateSync$2$createChild$followTailLink(new A.MemoryFile__doCreate_closure(false), true);
      if ((node == null ? null : node.get$type()) !== D.FileSystemEntityType_0)
        throw B.wrapException(A.isADirectory(this.path));
      return node;
    },
    length$0(_) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.int),
        $async$returnValue, $async$self = this;
      var $async$length$0 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = type$.FileNode._as($async$self.get$resolvedBacking())._content.length;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$length$0, $async$completer);
    },
    readAsBytes$0() {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.Uint8List),
        $async$returnValue, $async$self = this;
      var $async$readAsBytes$0 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $async$self.readAsBytesSync$0();
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$readAsBytes$0, $async$completer);
    },
    readAsBytesSync$0() {
      this.fileSystem.opHandle.call$2(this.path, D.FileSystemOp_0);
      return new Uint8Array(B._ensureNativeList(type$.FileNode._as(this.get$resolvedBacking())._content));
    },
    toString$0(_) {
      return "MemoryFile: '" + this.path + "'";
    },
    $isFile: 1,
    $isFile0: 1
  };
  A._FileSink.prototype = {
    get$isStreaming() {
      var t1 = this._streamCompleter;
      t1 = t1 == null ? null : (t1.future._state & 30) !== 0;
      return t1 === false;
    },
    addStream$1(stream) {
      var _this = this;
      if (_this.get$isStreaming())
        B.throwExpression(B.StateError$("StreamSink is bound to a stream"));
      _this._streamCompleter = new B._AsyncCompleter(new B._Future($.Zone__current, type$._Future_void), type$._AsyncCompleter_void);
      stream.listen$4$cancelOnError$onDone$onError(new A._FileSink_addStream_closure(_this), true, new A._FileSink_addStream_closure0(_this), new A._FileSink_addStream_closure1(_this));
      return _this._streamCompleter.future;
    },
    close$0() {
      var _this = this;
      if (_this.get$isStreaming())
        B.throwExpression(B.StateError$("StreamSink is bound to a stream"));
      if (!_this._memory_file$_isClosed) {
        _this._memory_file$_isClosed = true;
        _this._pendingWrites.then$1$2$onError(new A._FileSink_close_closure(_this), new A._FileSink_close_closure0(_this), type$.void);
      }
      return _this._completer.future;
    },
    _addData$1(data) {
      this._pendingWrites = this._pendingWrites.then$1$1(new A._FileSink__addData_closure(data), type$.FileNode);
    }
  };
  A.MemoryFileStat.prototype = {};
  A._MemoryFileSystem.prototype = {
    findNode$4$followTailLink$segmentVisitor$visitLinks(path, followTailLink, segmentVisitor, visitLinks) {
      var t1, reference, parts, directory, finalSegment, t2, t3, t4, t5, child, i, basename, t6, t7, _this = this, _null = null;
      if (path.length === 0)
        return _null;
      else {
        t1 = _this._memory_file_system$_context;
        if (t1.style.rootLength$1(path) > 0) {
          reference = _this._memory_file_system$_root;
          path = C.JSString_methods.substring$1(path, 0);
        } else {
          t1 = t1._context$_current;
          reference = type$.nullable_DirectoryNode._as(_this.findNode$1(t1 == null ? E.current() : t1));
        }
      }
      $.$get$Style_posix();
      parts = B._setArrayType(path.split("/"), type$.JSArray_String);
      C.JSArray_methods.removeWhere$1(parts, A.utils__isEmpty$closure());
      directory = reference == null ? _null : reference;
      finalSegment = parts.length - 1;
      for (t1 = segmentVisitor == null, t2 = !t1, t3 = type$.LinkNode, t4 = !visitLinks, t5 = type$.DirectoryNode, child = directory, i = 0; i <= finalSegment; ++i) {
        basename = parts[i];
        switch (basename) {
          case ".":
            child = directory;
            break;
          case "..":
            t6 = directory == null;
            child = t6 ? _null : directory.get$parent();
            directory = t6 ? _null : directory.get$parent();
            break;
          default:
            child = directory == null ? _null : directory.children.$index(0, basename);
        }
        t6 = new A._MemoryFileSystem_findNode_subpath(_this, parts, i);
        if ((child == null ? _null : child.get$type()) === D.FileSystemEntityType_2)
          t7 = i < finalSegment || followTailLink;
        else
          t7 = false;
        if (t7)
          if (!t4 || t1) {
            if (t2) {
              directory.toString;
              child = segmentVisitor.call$5(directory, basename, child, i, finalSegment);
            }
            child = A.resolveLinks(t3._as(child), t6, _null, _null);
          } else
            child = A.resolveLinks(t3._as(child), t6, _null, new A._MemoryFileSystem_findNode_closure(segmentVisitor, i, finalSegment));
        else if (t2) {
          directory.toString;
          child = segmentVisitor.call$5(directory, basename, child, i, finalSegment);
        }
        if (i < finalSegment) {
          if (child == null)
            B.throwExpression(A.noSuchFileOrDirectory(B._asString(t6.call$0())));
          t7 = child.get$type();
          if (t7 !== D.FileSystemEntityType_1)
            B.throwExpression(A.notADirectory(B._asString(t6.call$0())));
          t5._as(child);
          directory = child;
        }
      }
      return child;
    },
    findNode$1(path) {
      return this.findNode$4$followTailLink$segmentVisitor$visitLinks(path, false, null, false);
    }
  };
  A.MemoryFileSystemEntity.prototype = {
    get$backingOrNull() {
      var t1, exception;
      try {
        t1 = this.fileSystem.findNode$1(this.path);
        return t1;
      } catch (exception) {
        if (B.unwrapException(exception) instanceof A.FileSystemException)
          return null;
        else
          throw exception;
      }
    },
    get$backing() {
      var node = this.fileSystem.findNode$1(this.path);
      if (node == null)
        B.throwExpression(A.noSuchFileOrDirectory(B._asString(new A.MemoryFileSystemEntity_backing_closure(this).call$0())));
      return node;
    },
    get$resolvedBacking() {
      var _this = this,
        node = _this.get$backing(),
        t1 = node.get$type();
      if (t1 === D.FileSystemEntityType_2)
        node = A.resolveLinks(type$.LinkNode._as(node), new A.MemoryFileSystemEntity_resolvedBacking_closure(_this), null, null);
      A.checkType(_this.get$expectedType(), node.get$type(), new A.MemoryFileSystemEntity_resolvedBacking_closure0(_this));
      return node;
    },
    defaultCheckType$1(node) {
      A.checkType(this.get$expectedType(), node.get$stat().type, new A.MemoryFileSystemEntity_defaultCheckType_closure(this));
    },
    exists$0() {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.bool),
        $async$returnValue, $async$self = this;
      var $async$exists$0 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $async$self.existsSync$0();
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$exists$0, $async$completer);
    },
    delete$1$recursive(recursive) {
      return this.delete$body$MemoryFileSystemEntity(false);
    },
    delete$0() {
      return this.delete$1$recursive(false);
    },
    delete$body$MemoryFileSystemEntity(recursive) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.FileSystemEntity),
        $async$returnValue, $async$self = this;
      var $async$delete$1$recursive = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self.deleteSync$1$recursive(false);
              $async$returnValue = $async$self;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$delete$1$recursive, $async$completer);
    },
    deleteSync$1$recursive(recursive) {
      return this.internalDeleteSync$1$recursive(false);
    },
    internalCreateSync$3$createChild$followTailLink$visitLinks(createChild, followTailLink, visitLinks) {
      return this.fileSystem.findNode$4$followTailLink$segmentVisitor$visitLinks(this.path, true, new A.MemoryFileSystemEntity_internalCreateSync_closure(createChild), visitLinks);
    },
    internalCreateSync$2$createChild$followTailLink(createChild, followTailLink) {
      createChild.toString;
      return this.internalCreateSync$3$createChild$followTailLink$visitLinks(createChild, followTailLink, false);
    },
    internalDeleteSync$2$checkType$recursive(checkType, recursive) {
      var node, _this = this,
        t1 = _this.fileSystem,
        t2 = _this.path;
      t1.opHandle.call$2(t2, D.FileSystemOp_2);
      node = _this.get$backing();
      if (node instanceof A.DirectoryNode && node.children.__js_helper$_length !== 0)
        throw B.wrapException(A._fsException(t2, "Directory not empty", A.ErrorCodes_ENOTEMPTY()));
      (checkType == null ? _this.get$defaultCheckType() : checkType).call$1(node);
      node.get$parent().children.remove$1(0, E.ParsedPath_ParsedPath$parse(t2, t1._memory_file_system$_context.style).get$basename());
    },
    internalDeleteSync$1$recursive(recursive) {
      return this.internalDeleteSync$2$checkType$recursive(null, recursive);
    },
    $isFileSystemEntity: 1,
    $isFileSystemEntity0: 1
  };
  A.Node.prototype = {
    get$parent() {
      var t1 = this._node$_parent;
      t1.toString;
      return t1;
    },
    get$isRoot() {
      return false;
    }
  };
  A.RealNode.prototype = {
    RealNode$1($parent) {
      var _this = this;
      _this.get$clock();
      _this.__RealNode_accessed_A = _this.__RealNode_modified_A = _this.__RealNode_changed_A = Date.now();
    },
    get$clock() {
      return this.get$parent().get$clock();
    },
    get$stat() {
      var _this = this,
        t1 = _this.__RealNode_changed_A;
      t1 === $ && B.throwUnnamedLateFieldNI();
      B.DateTime__validate(t1, 0, false);
      t1 = _this.__RealNode_modified_A;
      t1 === $ && B.throwUnnamedLateFieldNI();
      B.DateTime__validate(t1, 0, false);
      t1 = _this.__RealNode_accessed_A;
      t1 === $ && B.throwUnnamedLateFieldNI();
      B.DateTime__validate(t1, 0, false);
      return new A.MemoryFileStat(_this.get$type(), _this.get$size());
    }
  };
  A.DirectoryNode.prototype = {
    get$type() {
      return D.FileSystemEntityType_1;
    },
    get$size() {
      return 0;
    }
  };
  A.RootNode.prototype = {
    get$clock() {
      return this.fs.clock;
    },
    get$parent() {
      return this;
    },
    get$isRoot() {
      return true;
    }
  };
  A.FileNode.prototype = {
    get$type() {
      return D.FileSystemEntityType_0;
    },
    get$size() {
      return this._content.length;
    }
  };
  A.FileSystemOp.prototype = {
    toString$0(_) {
      switch (this._operations$_value) {
        case 0:
          return "FileSystemOp.read";
        case 1:
          return "FileSystemOp.write";
        case 2:
          return "FileSystemOp.delete";
        case 3:
          return "FileSystemOp.create";
        case 4:
          return "FileSystemOp.open";
        case 5:
          return "FileSystemOp.copy";
        case 6:
          return "FileSystemOp.exists";
        default:
          throw B.wrapException(B.StateError$("Invalid FileSytemOp type: " + this.toString$0(0)));
      }
    }
  };
  A.FileSystemStyle.prototype = {};
  A._Posix.prototype = {};
  A.DirectoryAddOnsMixin.prototype = {};
  A._LinuxCodes.prototype = {$is_Codes: 1};
  A.FileSystem.prototype = {
    getPath$1(path) {
      if (typeof path == "string")
        return path;
      else
        throw B.wrapException(B.ArgumentError$('Invalid type for "path": ' + B.S(path == null ? null : C.JSString_methods.get$runtimeType(path)), null));
    }
  };
  A.FontLoader.prototype = {
    addFont$1(bytes) {
      if (this._font_loader$_loaded)
        throw B.wrapException(B.StateError$("FontLoader is already loaded"));
      this._fontFutures.push(bytes.then$1$1(new A.FontLoader_addFont_closure(), type$.Uint8List));
    },
    load$0() {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.void),
        $async$self = this, t1, t2;
      var $async$load$0 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if ($async$self._font_loader$_loaded)
                throw B.wrapException(B.StateError$("FontLoader is already loaded"));
              $async$self._font_loader$_loaded = true;
              t1 = $async$self._fontFutures;
              t2 = B._arrayInstanceType(t1)._eval$1("MappedListIterable<1,Future<~>>");
              t1 = B.List_List$_of(new B.MappedListIterable(t1, new A.FontLoader_load_closure($async$self), t2), t2._eval$1("ListIterable.E"));
              $async$goto = 2;
              return B._asyncAwait(B.Future_wait(t1, type$.void), $async$load$0);
            case 2:
              // returning from await.
              // implicit return
              return B._asyncReturn(null, $async$completer);
          }
      });
      return B._asyncStartSync($async$load$0, $async$completer);
    }
  };
  A.CacheManager.prototype = {
    downloadFile$2$key(url, key) {
      return this.downloadFile$body$CacheManager(url, key);
    },
    downloadFile$body$CacheManager(url, key) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.FileInfo),
        $async$returnValue, $async$self = this, t2, subject, t3, controller, wrapper, t1, $async$temp1;
      var $async$downloadFile$2$key = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.__CacheManager__webHelper_F;
              t1 === $ && B.throwUnnamedLateFieldNI();
              t2 = t1._memCache;
              subject = t2.$index(0, key);
              if (subject == null) {
                t3 = type$.FileResponse;
                controller = new B._AsyncBroadcastStreamController(null, null, type$._AsyncBroadcastStreamController_FileResponse);
                wrapper = new A._Wrapper(D.C__Empty, type$._Wrapper_FileResponse);
                subject = new A.BehaviorSubject(wrapper, controller, A.DeferStream$(A.BehaviorSubject__deferStream(wrapper, controller, false, t3), true, t3), type$.BehaviorSubject_FileResponse);
                t2.$indexSet(0, key, subject);
                t1._downloadOrAddToQueue$3(url, key, null);
              }
              $async$temp1 = type$.FileInfo;
              $async$goto = 3;
              return B._asyncAwait(new A._BehaviorSubjectStream(subject, subject.$ti._eval$1("_BehaviorSubjectStream<1>")).firstWhere$1(0, new A.CacheManager_downloadFile_closure()), $async$downloadFile$2$key);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1._as($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$downloadFile$2$key, $async$completer);
    }
  };
  A.CacheStore.prototype = {
    getFile$2$ignoreMemCache(key, ignoreMemCache) {
      return this.getFile$body$CacheStore(key, false);
    },
    getFile$body$CacheStore(key, ignoreMemCache) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.nullable_FileInfo),
        $async$returnValue, $async$self = this, file, cacheObject;
      var $async$getFile$2$ignoreMemCache = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return B._asyncAwait($async$self.retrieveCacheData$2$ignoreMemCache(key, false), $async$getFile$2$ignoreMemCache);
            case 3:
              // returning from await.
              cacheObject = $async$result;
              if (cacheObject == null) {
                $async$returnValue = null;
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 4;
              return B._asyncAwait($async$self.fileSystem.createFile$1(cacheObject.relativePath), $async$getFile$2$ignoreMemCache);
            case 4:
              // returning from await.
              file = $async$result;
              $.$get$cacheLogger();
              $async$returnValue = new A.FileInfo(file, cacheObject.validTill, cacheObject.url);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$getFile$2$ignoreMemCache, $async$completer);
    },
    putFile$1(cacheObject) {
      return this.putFile$body$CacheStore(cacheObject);
    },
    putFile$body$CacheStore(cacheObject) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.void),
        $async$self = this;
      var $async$putFile$1 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self._cache_store$_memCache.$indexSet(0, cacheObject.key, cacheObject);
              $async$goto = 2;
              return B._asyncAwait($async$self._updateCacheDataInDatabase$1(cacheObject), $async$putFile$1);
            case 2:
              // returning from await.
              // implicit return
              return B._asyncReturn(null, $async$completer);
          }
      });
      return B._asyncStartSync($async$putFile$1, $async$completer);
    },
    retrieveCacheData$2$ignoreMemCache(key, ignoreMemCache) {
      return this.retrieveCacheData$body$CacheStore(key, false);
    },
    retrieveCacheData$1(key) {
      return this.retrieveCacheData$2$ignoreMemCache(key, false);
    },
    retrieveCacheData$body$CacheStore(key, ignoreMemCache) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.nullable_CacheObject),
        $async$returnValue, $async$self = this, t1, t2;
      var $async$retrieveCacheData$2$ignoreMemCache = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._cache_store$_memCache;
              t2 = t1.containsKey$1(key);
              $async$goto = t2 ? 3 : 4;
              break;
            case 3:
              // then
              $async$goto = 5;
              return B._asyncAwait($async$self._fileExists$1(t1.$index(0, key)), $async$retrieveCacheData$2$ignoreMemCache);
            case 5:
              // returning from await.
              if ($async$result) {
                $async$returnValue = t1.$index(0, key);
                // goto return
                $async$goto = 1;
                break;
              }
            case 4:
              // join
              t1 = $async$self._futureCache;
              if (!t1.containsKey$1(key)) {
                t2 = new B._Future($.Zone__current, type$._Future_nullable_CacheObject);
                $async$self._getCacheDataFromDatabase$1(key).then$1$1(new A.CacheStore_retrieveCacheData_closure($async$self, key, new B._AsyncCompleter(t2, type$._AsyncCompleter_nullable_CacheObject)), type$.Null);
                t1.$indexSet(0, key, t2);
              }
              $async$returnValue = t1.$index(0, key);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$retrieveCacheData$2$ignoreMemCache, $async$completer);
    },
    _fileExists$1(cacheObject) {
      return this._fileExists$body$CacheStore(cacheObject);
    },
    _fileExists$body$CacheStore(cacheObject) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.bool),
        $async$returnValue, $async$self = this;
      var $async$_fileExists$1 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (cacheObject == null) {
                $async$returnValue = false;
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return B._asyncAwait($async$self.fileSystem.createFile$1(cacheObject.relativePath), $async$_fileExists$1);
            case 3:
              // returning from await.
              $async$returnValue = $async$result.exists$0();
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$_fileExists$1, $async$completer);
    },
    _getCacheDataFromDatabase$1(key) {
      return this._getCacheDataFromDatabase$body$CacheStore(key);
    },
    _getCacheDataFromDatabase$body$CacheStore(key) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.nullable_CacheObject),
        $async$returnValue, $async$self = this, data;
      var $async$_getCacheDataFromDatabase$1 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return B._asyncAwait($async$self._cacheInfoRepository, $async$_getCacheDataFromDatabase$1);
            case 3:
              // returning from await.
              $async$goto = 4;
              return B._asyncAwait(B.Future_Future$value(null, type$.nullable_CacheObject), $async$_getCacheDataFromDatabase$1);
            case 4:
              // returning from await.
              data = $async$result;
              $async$goto = 5;
              return B._asyncAwait($async$self._fileExists$1(data), $async$_getCacheDataFromDatabase$1);
            case 5:
              // returning from await.
              if ($async$result) {
                data.toString;
                $async$self._updateCacheDataInDatabase$1(data);
              }
              $async$self._scheduleCleanup$0();
              $async$returnValue = data;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$_getCacheDataFromDatabase$1, $async$completer);
    },
    _scheduleCleanup$0() {
      if (this._scheduledCleanup != null)
        return;
      this._scheduledCleanup = B.Timer_Timer(D.Duration_10000000, new A.CacheStore__scheduleCleanup_closure(this));
    },
    _updateCacheDataInDatabase$1(cacheObject) {
      return this._updateCacheDataInDatabase$body$CacheStore(cacheObject);
    },
    _updateCacheDataInDatabase$body$CacheStore(cacheObject) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.dynamic),
        $async$returnValue, $async$self = this;
      var $async$_updateCacheDataInDatabase$1 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return B._asyncAwait($async$self._cacheInfoRepository, $async$_updateCacheDataInDatabase$1);
            case 3:
              // returning from await.
              $async$returnValue = B.Future_Future$value(null, type$.dynamic);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$_updateCacheDataInDatabase$1, $async$completer);
    },
    _cleanupCache$0() {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.void),
        $async$self = this, t1, t2, t3, toRemove, $async$temp1;
      var $async$_cleanupCache$0 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              toRemove = B._setArrayType([], type$.JSArray_int);
              $async$goto = 2;
              return B._asyncAwait($async$self._cacheInfoRepository, $async$_cleanupCache$0);
            case 2:
              // returning from await.
              t1 = type$.JSArray_CacheObject;
              t2 = type$.List_CacheObject;
              $async$temp1 = J;
              $async$goto = 3;
              return B._asyncAwait(B.Future_Future$value(B._setArrayType([], t1), t2), $async$_cleanupCache$0);
            case 3:
              // returning from await.
              t3 = $async$temp1.get$iterator$ax($async$result);
            case 4:
              // for condition
              if (!t3.moveNext$0()) {
                // goto after for
                $async$goto = 5;
                break;
              }
              $async$self._removeCachedFile$2(t3.get$current(), toRemove);
              // goto for condition
              $async$goto = 4;
              break;
            case 5:
              // after for
              $async$temp1 = J;
              $async$goto = 6;
              return B._asyncAwait(B.Future_Future$value(B._setArrayType([], t1), t2), $async$_cleanupCache$0);
            case 6:
              // returning from await.
              t1 = $async$temp1.get$iterator$ax($async$result);
            case 7:
              // for condition
              if (!t1.moveNext$0()) {
                // goto after for
                $async$goto = 8;
                break;
              }
              $async$self._removeCachedFile$2(t1.get$current(), toRemove);
              // goto for condition
              $async$goto = 7;
              break;
            case 8:
              // after for
              $async$goto = 9;
              return B._asyncAwait(B.Future_Future$value(toRemove.length, type$.int), $async$_cleanupCache$0);
            case 9:
              // returning from await.
              // implicit return
              return B._asyncReturn(null, $async$completer);
          }
      });
      return B._asyncStartSync($async$_cleanupCache$0, $async$completer);
    },
    _removeCachedFile$2(cacheObject, toRemove) {
      return this._removeCachedFile$body$CacheStore(cacheObject, toRemove);
    },
    _removeCachedFile$body$CacheStore(cacheObject, toRemove) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.void),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], $async$self = this, file, t2, exception, t1, $async$exception;
      var $async$_removeCachedFile$2 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = cacheObject.id;
              if (C.JSArray_methods.contains$1(toRemove, t1)) {
                // goto return
                $async$goto = 1;
                break;
              }
              t1.toString;
              toRemove.push(t1);
              t1 = $async$self._cache_store$_memCache;
              t2 = cacheObject.key;
              if (t1.containsKey$1(t2))
                t1.remove$1(0, t2);
              t1 = $async$self._futureCache;
              $async$goto = t1.containsKey$1(t2) ? 3 : 4;
              break;
            case 3:
              // then
              t1 = t1.remove$1(0, t2);
              $async$goto = 5;
              return B._asyncAwait(type$.Future_nullable_CacheObject._is(t1) ? t1 : B._Future$value(t1, type$.nullable_CacheObject), $async$_removeCachedFile$2);
            case 5:
              // returning from await.
            case 4:
              // join
              file = A.File_File(cacheObject.relativePath);
              $async$goto = file.existsSync$0() ? 6 : 7;
              break;
            case 6:
              // then
              $async$handler = 9;
              $async$goto = 12;
              return B._asyncAwait(file.delete$0(), $async$_removeCachedFile$2);
            case 12:
              // returning from await.
              $async$handler = 2;
              // goto after finally
              $async$goto = 11;
              break;
            case 9:
              // catch
              $async$handler = 8;
              $async$exception = $async$errorStack.pop();
              if (!(B.unwrapException($async$exception) instanceof A.PathNotFoundException))
                throw $async$exception;
              // goto after finally
              $async$goto = 11;
              break;
            case 8:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 11:
              // after finally
            case 7:
              // join
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return B._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return B._asyncStartSync($async$_removeCachedFile$2, $async$completer);
    }
  };
  A.Config.prototype = {};
  A.CacheLogger.prototype = {};
  A.DownloadProgress.prototype = {};
  A.FileInfo.prototype = {};
  A.FileResponse.prototype = {};
  A.NonStoringObjectProvider.prototype = {
    open$0() {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.bool),
        $async$returnValue;
      var $async$open$0 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = true;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$open$0, $async$completer);
    },
    $isCacheInfoRepository: 1
  };
  A.CacheObject.prototype = {
    copyWith$6$eTag$id$length$relativePath$url$validTill(eTag, id, $length, relativePath, url, validTill) {
      var _this = this,
        t1 = url == null ? _this.url : url,
        t2 = relativePath == null ? _this.relativePath : relativePath,
        t3 = validTill == null ? _this.validTill : validTill,
        t4 = eTag == null ? _this.eTag : eTag,
        t5 = $length == null ? _this.length : $length;
      return A.CacheObject$(t1, t4, _this.id, _this.key, t5, t2, _this.touched, t3);
    },
    copyWith$1$url(url) {
      var _null = null;
      return this.copyWith$6$eTag$id$length$relativePath$url$validTill(_null, _null, _null, _null, url, _null);
    },
    copyWith$3$eTag$relativePath$validTill(eTag, relativePath, validTill) {
      return this.copyWith$6$eTag$id$length$relativePath$url$validTill(eTag, null, null, relativePath, null, validTill);
    },
    copyWith$1$length($length) {
      var _null = null;
      return this.copyWith$6$eTag$id$length$relativePath$url$validTill(_null, _null, $length, _null, _null, _null);
    },
    get$length(receiver) {
      return this.length;
    }
  };
  A.MemoryCacheSystem.prototype = {
    createFile$1($name) {
      return this.createFile$body$MemoryCacheSystem($name);
    },
    createFile$body$MemoryCacheSystem($name) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.File_2),
        $async$returnValue, $async$self = this, t1, t2;
      var $async$createFile$1 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return B._asyncAwait($async$self.directory, $async$createFile$1);
            case 3:
              // returning from await.
              t1 = $async$result;
              t2 = t1.fileSystem;
              $async$returnValue = new A.MemoryFile(t2, t2.getPath$1(t2._memory_file_system$_context.join$2(0, t1.path, $name)));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$createFile$1, $async$completer);
    }
  };
  A.FileService.prototype = {};
  A.HttpFileService.prototype = {
    $get$2$headers(url, headers) {
      return this.$get$body$HttpFileService(url, headers);
    },
    $get$body$HttpFileService(url, headers) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.FileServiceResponse),
        $async$returnValue, $async$self = this, httpResponse, req;
      var $async$$get$2$headers = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              req = E.Request$("GET", B.Uri_parse(url));
              req.headers.addAll$1(0, headers);
              $async$goto = 3;
              return B._asyncAwait($async$self._httpClient.send$1(req), $async$$get$2$headers);
            case 3:
              // returning from await.
              httpResponse = $async$result;
              A.clock();
              $async$returnValue = new A.HttpGetResponse(A.systemTime(), httpResponse);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$$get$2$headers, $async$completer);
    }
  };
  A.HttpGetResponse.prototype = {
    get$statusCode() {
      return this._response.statusCode;
    },
    get$validTill() {
      var controlSettings, t1, ageDuration, _i, sanitizedSetting, validSeconds,
        controlHeader = this._response.headers.$index(0, "cache-control");
      if (controlHeader != null) {
        controlSettings = controlHeader.split(",");
        for (t1 = controlSettings.length, ageDuration = D.Duration_604800000000, _i = 0; _i < t1; ++_i) {
          sanitizedSetting = C.JSString_methods.trim$0(controlSettings[_i]).toLowerCase();
          if (sanitizedSetting === "no-cache")
            ageDuration = C.Duration_0;
          if (C.JSString_methods.startsWith$1(sanitizedSetting, "max-age=")) {
            validSeconds = B.Primitives_parseInt(sanitizedSetting.split("=")[1], null);
            if (validSeconds == null)
              validSeconds = 0;
            if (validSeconds > 0)
              ageDuration = new B.Duration(1000000 * validSeconds);
          }
        }
      } else
        ageDuration = D.Duration_604800000000;
      return this._receivedTime._addMicroseconds$1(ageDuration._duration);
    },
    $isFileServiceResponse: 1
  };
  A.QueueItem.prototype = {};
  A.WebHelper.prototype = {
    _downloadOrAddToQueue$3(url, key, authHeaders) {
      return this._downloadOrAddToQueue$body$WebHelper(url, key, authHeaders);
    },
    _downloadOrAddToQueue$body$WebHelper(url, key, authHeaders) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.void),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], $async$next = [], $async$self = this, subject, result, e, stackTrace, t2, t3, t4, t5, exception, t1, $async$exception;
      var $async$_downloadOrAddToQueue$3 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.concurrentCalls;
              if (t1 >= 10) {
                $async$self._web_helper$_queue._collection$_add$1(new A.QueueItem(url, key, authHeaders));
                // goto return
                $async$goto = 1;
                break;
              }
              $.$get$cacheLogger();
              $async$self.concurrentCalls = t1 + 1;
              t1 = $async$self._memCache;
              t2 = t1.$index(0, key);
              t2.toString;
              subject = t2;
              $async$handler = 4;
              t2 = new B._StreamIterator(B.checkNotNullable($async$self._updateFile$3$authHeaders(url, key, authHeaders), "stream", type$.Object), type$._StreamIterator_FileResponse);
              $async$handler = 7;
            case 10:
              // for condition
              $async$goto = 12;
              return B._asyncAwait(t2.moveNext$0(), $async$_downloadOrAddToQueue$3);
            case 12:
              // returning from await.
              if (!$async$result) {
                // goto after for
                $async$goto = 11;
                break;
              }
              result = t2.get$current();
              t3 = subject;
              t4 = result;
              if (t3._isAddingStreamItems)
                B.throwExpression(B.StateError$(string$.You_ca));
              t5 = t3._subject$_controller;
              if ((t5._state & 4) === 0) {
                t3 = t3._wrapper;
                t3.value = t4;
                t3.isValue = true;
              }
              if (!t5.get$_mayAddEvent())
                B.throwExpression(t5._addEventError$0());
              t5._sendData$1(t4);
              // goto for condition
              $async$goto = 10;
              break;
            case 11:
              // after for
              $async$next.push(9);
              // goto finally
              $async$goto = 8;
              break;
            case 7:
              // uncaught
              $async$next = [4];
            case 8:
              // finally
              $async$handler = 4;
              $async$goto = 13;
              return B._asyncAwait(t2.cancel$0(), $async$_downloadOrAddToQueue$3);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 9:
              // after finally
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$errorStack.pop();
              e = B.unwrapException($async$exception);
              stackTrace = B.getTraceFromException($async$exception);
              subject.addError$2(e, stackTrace);
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 5:
              // finally
              $async$handler = 2;
              --$async$self.concurrentCalls;
              $async$goto = 14;
              return B._asyncAwait(subject.close$0(), $async$_downloadOrAddToQueue$3);
            case 14:
              // returning from await.
              t1.remove$1(0, key);
              $async$self._checkQueue$0();
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 6:
              // after finally
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return B._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return B._asyncStartSync($async$_downloadOrAddToQueue$3, $async$completer);
    },
    _checkQueue$0() {
      var next,
        t1 = this._web_helper$_queue;
      if (t1._head === t1._tail)
        return;
      next = t1.removeFirst$0();
      this._downloadOrAddToQueue$3(next.url, next.key, next.headers);
    },
    _updateFile$3$authHeaders(url, key, authHeaders) {
      return this._updateFile$body$WebHelper(url, key, authHeaders);
    },
    _updateFile$body$WebHelper(url, key, authHeaders) {
      var $async$_updateFile$3$authHeaders = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$errorStack.push($async$result);
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 3;
              return E._asyncStarHelper($async$self._store.retrieveCacheData$1(key), $async$_updateFile$3$authHeaders, $async$controller);
            case 3:
              // returning from await.
              cacheObject = $async$result;
              if (cacheObject == null) {
                A.clock();
                t1 = A.systemTime();
                cacheObject = A.CacheObject$(url, null, null, key, null, D.C_Uuid.v1$0() + ".file", null, t1);
              } else
                cacheObject = cacheObject.copyWith$1$url(url);
              t1 = type$.String;
              $async$temp1 = cacheObject;
              $async$goto = 5;
              return E._asyncStarHelper($async$self.fileFetcher.$get$2$headers(cacheObject.url, B.LinkedHashMap_LinkedHashMap$_empty(t1, t1)), $async$_updateFile$3$authHeaders, $async$controller);
            case 5:
              // returning from await.
              $async$goto = 4;
              $async$nextWhenCanceled = [1];
              return E._asyncStarHelper(E._IterationMarker_yieldStar($async$self._manageResponse$2($async$temp1, $async$result)), $async$_updateFile$3$authHeaders, $async$controller);
            case 4:
              // after yield
            case 1:
              // return
              return E._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return E._asyncStarHelper($async$errorStack.at(-1), 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = E._makeAsyncStarStreamController($async$_updateFile$3$authHeaders, type$.FileResponse),
        $async$nextWhenCanceled, $async$handler = 2, $async$errorStack = [], $async$next = [], $async$self = this, t1, cacheObject, $async$temp1;
      return E._streamOfController($async$controller);
    },
    _manageResponse$2(cacheObject, response) {
      return this._manageResponse$body$WebHelper(cacheObject, response);
    },
    _manageResponse$body$WebHelper(cacheObject, response) {
      var $async$_manageResponse$2 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$errorStack.push($async$result);
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              _box_0 = {};
              t1 = response._response;
              t2 = t1.statusCode;
              hasNewFile = C.JSArray_methods.contains$1(D.List_200_202, t2);
              keepOldFile = C.JSArray_methods.contains$1(D.List_304, t2);
              if (!hasNewFile && !keepOldFile) {
                response.get$statusCode();
                throw B.wrapException(new A.HttpExceptionWithStatus("Invalid statusCode: " + response.get$statusCode(), B.Uri_parse(cacheObject.url)));
              }
              t1 = t1.headers;
              contentTypeHeader = t1.$index(0, "content-type");
              if (contentTypeHeader != null) {
                result = new A._ContentType();
                result._HeaderValue$2("", D.Map_empty3);
                result._parse$4(contentTypeHeader, ";", null, false);
                t3 = result.__http$_value;
                index = C.JSString_methods.indexOf$1(t3, "/");
                if (index === -1 || index === t3.length - 1)
                  t3 = result._primaryType = C.JSString_methods.trim$0(t3).toLowerCase();
                else {
                  t4 = result._primaryType = C.JSString_methods.trim$0(C.JSString_methods.substring$2(t3, 0, index)).toLowerCase();
                  result._subType = C.JSString_methods.trim$0(C.JSString_methods.substring$1(t3, index + 1)).toLowerCase();
                  t3 = t4;
                }
                fileExtension = D.Map_Iuz2d.$index(0, t3 + "/" + result._subType);
                if (fileExtension == null)
                  fileExtension = "." + result._subType;
              } else
                fileExtension = "";
              filePath = cacheObject.relativePath;
              if (!C.JSArray_methods.contains$1(D.List_304, t2)) {
                if (!C.JSString_methods.endsWith$1(filePath, fileExtension))
                  $async$self._removeOldFile$1(filePath);
                filePath = D.C_Uuid.v1$0() + fileExtension;
              }
              t3 = response.get$validTill();
              newCacheObject = _box_0.newCacheObject = cacheObject.copyWith$3$eTag$relativePath$validTill(t1.$index(0, "etag"), filePath, t3);
              $async$goto = C.JSArray_methods.contains$1(D.List_200_202, t2) ? 3 : 5;
              break;
            case 3:
              // then
              savedBytes = 0;
              receivedBytesResultController = B.StreamController_StreamController(null, null, null, false, type$.int);
              $async$self._saveFileAndPostUpdates$3(receivedBytesResultController, newCacheObject, response);
              t1 = new B._StreamIterator(B.checkNotNullable(new B._ControllerStream(receivedBytesResultController, B._instanceType(receivedBytesResultController)._eval$1("_ControllerStream<1>")), "stream", type$.Object), type$._StreamIterator_int);
              $async$handler = 6;
              t2 = cacheObject.url;
            case 9:
              // for condition
              $async$goto = 11;
              return E._asyncStarHelper(t1.moveNext$0(), $async$_manageResponse$2, $async$controller);
            case 11:
              // returning from await.
              if (!$async$result) {
                // goto after for
                $async$goto = 10;
                break;
              }
              progress = t1.get$current();
              savedBytes = progress;
              $async$goto = 12;
              $async$nextWhenCanceled = [1, 7];
              return E._asyncStarHelper(E._IterationMarker_yieldSingle(new A.DownloadProgress(t2)), $async$_manageResponse$2, $async$controller);
            case 12:
              // after yield
              // goto for condition
              $async$goto = 9;
              break;
            case 10:
              // after for
              $async$next.push(8);
              // goto finally
              $async$goto = 7;
              break;
            case 6:
              // uncaught
              $async$next = [2];
            case 7:
              // finally
              $async$handler = 2;
              $async$goto = 13;
              return E._asyncStarHelper(t1.cancel$0(), $async$_manageResponse$2, $async$controller);
            case 13:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 8:
              // after finally
              t1 = _box_0.newCacheObject = _box_0.newCacheObject.copyWith$1$length(savedBytes);
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              t1 = newCacheObject;
            case 4:
              // join
              t2 = $async$self._store;
              t2.putFile$1(t1).then$1$1(new A.WebHelper__manageResponse_closure(_box_0, $async$self, cacheObject), type$.Null);
              $async$goto = 14;
              return E._asyncStarHelper(t2.fileSystem.createFile$1(_box_0.newCacheObject.relativePath), $async$_manageResponse$2, $async$controller);
            case 14:
              // returning from await.
              file = $async$result;
              t2 = _box_0.newCacheObject;
              $async$goto = 15;
              $async$nextWhenCanceled = [1];
              return E._asyncStarHelper(E._IterationMarker_yieldSingle(new A.FileInfo(file, t2.validTill, t2.url)), $async$_manageResponse$2, $async$controller);
            case 15:
              // after yield
            case 1:
              // return
              return E._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return E._asyncStarHelper($async$errorStack.at(-1), 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = E._makeAsyncStarStreamController($async$_manageResponse$2, type$.FileResponse),
        $async$nextWhenCanceled, $async$handler = 2, $async$errorStack = [], $async$next = [], $async$self = this, savedBytes, progress, contentTypeHeader, result, t3, index, t4, fileExtension, filePath, newCacheObject, receivedBytesResultController, file, _box_0, t1, t2, hasNewFile, keepOldFile;
      return E._streamOfController($async$controller);
    },
    _saveFileAndPostUpdates$3(receivedBytesResultController, cacheObject, response) {
      return this._saveFileAndPostUpdates$body$WebHelper(receivedBytesResultController, cacheObject, response);
    },
    _saveFileAndPostUpdates$body$WebHelper(receivedBytesResultController, cacheObject, response) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.void),
        $async$handler = 1, $async$errorStack = [], $async$self = this, sink, e, stacktrace, t1, t2, exception, file, $async$exception;
      var $async$_saveFileAndPostUpdates$3 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return B._asyncAwait($async$self._store.fileSystem.createFile$1(cacheObject.relativePath), $async$_saveFileAndPostUpdates$3);
            case 2:
              // returning from await.
              file = $async$result;
              $async$handler = 4;
              t1 = {};
              t1.receivedBytes = 0;
              t2 = file;
              t2.fileSystem.opHandle.call$2(t2.path, D.FileSystemOp_4);
              sink = A._FileSink__FileSink$fromFile(t2, D.C_FileMode, C.C_Utf8Codec);
              t2 = response._response.stream;
              $async$goto = 7;
              return B._asyncAwait(new B._MapStream(new A.WebHelper__saveFileAndPostUpdates_closure(t1, receivedBytesResultController), t2, B._instanceType(t2)._eval$1("_MapStream<Stream.T,List<int>>")).pipe$1(sink), $async$_saveFileAndPostUpdates$3);
            case 7:
              // returning from await.
              $async$handler = 1;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$errorStack.pop();
              e = B.unwrapException($async$exception);
              stacktrace = B.getTraceFromException($async$exception);
              receivedBytesResultController.addError$2(e, stacktrace);
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 1;
              break;
            case 6:
              // after finally
              $async$goto = 8;
              return B._asyncAwait(receivedBytesResultController.close$0(), $async$_saveFileAndPostUpdates$3);
            case 8:
              // returning from await.
              // implicit return
              return B._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return B._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return B._asyncStartSync($async$_saveFileAndPostUpdates$3, $async$completer);
    },
    _removeOldFile$1(relativePath) {
      return this._removeOldFile$body$WebHelper(relativePath);
    },
    _removeOldFile$body$WebHelper(relativePath) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.void),
        $async$self = this, file;
      var $async$_removeOldFile$1 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return B._asyncAwait($async$self._store.fileSystem.createFile$1(relativePath), $async$_removeOldFile$1);
            case 2:
              // returning from await.
              file = $async$result;
              $async$goto = 5;
              return B._asyncAwait(file.exists$0(), $async$_removeOldFile$1);
            case 5:
              // returning from await.
              $async$goto = $async$result ? 3 : 4;
              break;
            case 3:
              // then
              $async$goto = 6;
              return B._asyncAwait(file.delete$0(), $async$_removeOldFile$1);
            case 6:
              // returning from await.
            case 4:
              // join
              // implicit return
              return B._asyncReturn(null, $async$completer);
          }
      });
      return B._asyncStartSync($async$_removeOldFile$1, $async$completer);
    }
  };
  A.HttpExceptionWithStatus.prototype = {};
  A.DeferStream.prototype = {
    get$isBroadcast() {
      return true;
    },
    listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError) {
      var e, s, exception, _0_0, t1, t2, _null = null, stream = null;
      try {
        stream = this._factory.call$0();
      } catch (exception) {
        e = B.unwrapException(exception);
        s = B.getTraceFromException(exception);
        _0_0 = B._interceptUserError(e, s);
        t1 = this.$ti._eval$1("_AsyncStreamController<1>");
        t2 = new B._AsyncStreamController(_null, _null, _null, _null, t1);
        t2._addError$2(_0_0.error, _0_0.stackTrace);
        t2._closeUnchecked$0();
        return new B._ControllerStream(t2, t1._eval$1("_ControllerStream<1>")).listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
      }
      return stream.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
    },
    listen$3$onDone$onError(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    }
  };
  A.BehaviorSubject.prototype = {
    get$stream() {
      return new A._BehaviorSubjectStream(this, this.$ti._eval$1("_BehaviorSubjectStream<1>"));
    }
  };
  A._Wrapper.prototype = {};
  A._BehaviorSubjectStream.prototype = {
    get$isBroadcast() {
      return true;
    },
    get$hashCode(_) {
      return (B.Primitives_objectHashCode(this._subject) ^ 892482866) >>> 0;
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      return other instanceof A._BehaviorSubjectStream && other._subject === this._subject;
    },
    listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError) {
      return this._subject.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
    },
    listen$3$onDone$onError(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    }
  };
  A.Subject.prototype = {
    get$stream() {
      return new A._SubjectStream(this, this.$ti._eval$1("_SubjectStream<1>"));
    },
    addError$2(error, stackTrace) {
      if (this._isAddingStreamItems)
        throw B.wrapException(B.StateError$("You cannot add an error while items are being added from addStream"));
      this._subject$_addError$2(error, stackTrace);
    },
    _subject$_addError$2(error, stackTrace) {
      var t2,
        t1 = this._subject$_controller;
      if ((t1._state & 4) === 0) {
        t2 = this._wrapper;
        t2.errorAndStackTrace = new A.ErrorAndStackTrace(error, stackTrace);
        t2.isValue = false;
      }
      t1.addError$2(error, stackTrace);
    },
    add$1(_, $event) {
      if (this._isAddingStreamItems)
        throw B.wrapException(B.StateError$(string$.You_ca));
      this._subject$_add$1($event);
    },
    _subject$_add$1($event) {
      var t2,
        t1 = this._subject$_controller;
      if ((t1._state & 4) === 0) {
        t2 = this._wrapper;
        t2.value = $event;
        t2.isValue = true;
      }
      t1.add$1(0, $event);
    },
    close$0() {
      if (this._isAddingStreamItems)
        throw B.wrapException(B.StateError$("You cannot close the subject while items are being added from addStream"));
      return this._subject$_controller.close$0();
    }
  };
  A._SubjectStream.prototype = {
    get$isBroadcast() {
      return true;
    },
    get$hashCode(_) {
      return (B.Primitives_objectHashCode(this._subject$_subject) ^ 892482866) >>> 0;
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      return other instanceof A._SubjectStream && other._subject$_subject === this._subject$_subject;
    },
    listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError) {
      return this._subject$_subject.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
    },
    listen$3$onDone$onError(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    }
  };
  A._StartWithStreamSink.prototype = {
    onData$1(data) {
      return this.get$sink().add$1(0, data);
    },
    onError$2(e, st) {
      return this.get$sink().addError$2(e, st);
    },
    onDone$0() {
      return this.get$sink().close$0();
    },
    onCancel$0() {
    },
    onListen$0() {
      this.get$sink().add$1(0, this._startValue);
    },
    onPause$0() {
    },
    onResume$0() {
    }
  };
  A.StartWithStreamTransformer.prototype = {
    bind$1(stream) {
      var t1 = this.$ti._precomputed1;
      return A.forwardStream(stream, new A.StartWithStreamTransformer_bind_closure(this), t1, t1);
    }
  };
  A._StartWithErrorStreamSink.prototype = {
    onData$1(data) {
      return this.get$sink().add$1(0, data);
    },
    onError$2(e, st) {
      return this.get$sink().addError$2(e, st);
    },
    onDone$0() {
      return this.get$sink().close$0();
    },
    onCancel$0() {
    },
    onListen$0() {
      this.get$sink().addError$2(this._e, this._st);
    },
    onPause$0() {
    },
    onResume$0() {
    }
  };
  A.StartWithErrorStreamTransformer.prototype = {
    bind$1(stream) {
      var t1 = this.$ti._precomputed1;
      return A.forwardStream(stream, new A.StartWithErrorStreamTransformer_bind_closure(this), t1, t1);
    }
  };
  A._Empty.prototype = {
    toString$0(_) {
      return "<<EMPTY>>";
    }
  };
  A.ErrorAndStackTrace.prototype = {
    toString$0(_) {
      return "ErrorAndStackTrace{error: " + B.S(this.error) + ", stackTrace: " + B.S(this.stackTrace) + "}";
    },
    $eq(_, other) {
      var t1, _this = this;
      if (other == null)
        return false;
      if (_this !== other)
        t1 = other instanceof A.ErrorAndStackTrace && B.getRuntimeTypeOfDartObject(_this) === B.getRuntimeTypeOfDartObject(other) && J.$eq$(_this.error, other.error) && _this.stackTrace == other.stackTrace;
      else
        t1 = true;
      return t1;
    },
    get$hashCode(_) {
      return (J.get$hashCode$(this.error) ^ J.get$hashCode$(this.stackTrace)) >>> 0;
    }
  };
  A.ForwardingSink.prototype = {
    get$sink() {
      var t1 = this._forwarding_sink$_sink;
      return t1 == null ? B.throwExpression(B.StateError$("Must call setSink(sink) before accessing!")) : t1;
    }
  };
  A._MultiControllerSink.prototype = {
    add$1(_, $event) {
      return this.controller.addSync$1($event);
    },
    addError$2(error, stackTrace) {
      return this.controller.addErrorSync$2(error, stackTrace);
    },
    close$0() {
      return this.controller.closeSync$0();
    }
  };
  A._EnhancedEventSink.prototype = {
    add$1(_, $event) {
      return this._forwarding_stream$_controller.add$1(0, $event);
    },
    addError$2(error, stackTrace) {
      return this._forwarding_stream$_controller.addError$2(error, stackTrace);
    },
    close$0() {
      return this._forwarding_stream$_controller.close$0();
    }
  };
  A.ChapterInfo.prototype = {};
  A.Chapter.prototype = {
    get$id() {
      return this.info.id;
    },
    get$varName() {
      return this.info.varName;
    },
    get$displayTitle() {
      return this.info.displayName;
    },
    get$nextId() {
      return this.info.next;
    },
    $index(_, ix) {
      var t1 = this.lines;
      if (ix < t1.length)
        return t1[ix];
      else
        return null;
    },
    get$length(_) {
      return this.lines.length;
    },
    get$isTitle() {
      return this.info.varName === "Title";
    },
    get$debugId() {
      return this.info.varName;
    },
    _addHolderFromStream$1(h) {
      this.lines.push(h);
    },
    addAndRegisterError$2(excep, trace) {
      var errorElem;
      B.S(excep);
      if (trace == null)
        trace = B.StackTrace_current();
      trace.toString$0(0);
      errorElem = new B.ExceptionHolder(excep, trace);
      this.lines.push(errorElem);
      $.$get$ErrorList_instance().list.push(errorElem);
    },
    addAndRegisterError$1(excep) {
      return this.addAndRegisterError$2(excep, null);
    },
    postLoadCleanup$0() {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.void),
        $async$self = this, topElement, t1;
      var $async$postLoadCleanup$0 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.lines;
              if (t1.length !== 0) {
                topElement = t1[0];
                if (topElement instanceof A.HeaderOfText) {
                  $async$self.header = topElement;
                  C.JSArray_methods.removeAt$1(t1, 0);
                }
              }
              $async$self.awaitFutures$0();
              $async$self.notifyListeners$0();
              // implicit return
              return B._asyncReturn(null, $async$completer);
          }
      });
      return B._asyncStartSync($async$postLoadCleanup$0, $async$completer);
    },
    awaitFutures$0() {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.void),
        $async$handler = 1, $async$errorStack = [], $async$self = this, ix, holder, newHolder, exception, trace, t1, exception0, t2, t3, $async$exception0;
      var $async$awaitFutures$0 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              ix = 0, t1 = $async$self.lines;
            case 2:
              // for condition
              if (!(ix < t1.length)) {
                // goto after for
                $async$goto = 4;
                break;
              }
              holder = t1[ix];
              $async$goto = holder instanceof A.FutureHolder ? 5 : 6;
              break;
            case 5:
              // then
              $async$handler = 8;
              $async$goto = 11;
              return B._asyncAwait(holder.holder, $async$awaitFutures$0);
            case 11:
              // returning from await.
              newHolder = $async$result;
              t1[ix] = newHolder;
              $async$handler = 1;
              // goto after finally
              $async$goto = 10;
              break;
            case 8:
              // catch
              $async$handler = 7;
              $async$exception0 = $async$errorStack.pop();
              exception = B.unwrapException($async$exception0);
              trace = B.getTraceFromException($async$exception0);
              t2 = trace;
              t3 = $.$get$ErrorList_instance();
              if (t2 == null)
                t2 = B.StackTrace_current();
              t3.list.push(new B.ExceptionHolder(exception, t2));
              // goto after finally
              $async$goto = 10;
              break;
            case 7:
              // uncaught
              // goto rethrow
              $async$goto = 1;
              break;
            case 10:
              // after finally
            case 6:
              // join
            case 3:
              // for update
              ++ix;
              // goto for condition
              $async$goto = 2;
              break;
            case 4:
              // after for
              $async$self.notifyListeners$0();
              // implicit return
              return B._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return B._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return B._asyncStartSync($async$awaitFutures$0, $async$completer);
    }
  };
  A.ChapterParser.prototype = {
    parseWithExistingChapterInfo$2$handleErrors(info, handleErrors) {
      return this.parseWithExistingChapterInfo$body$ChapterParser(info, true);
    },
    parseWithExistingChapterInfo$body$ChapterParser(info, handleErrors) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.Chapter),
        $async$returnValue, $async$self = this, spans, t1;
      var $async$parseWithExistingChapterInfo$2$handleErrors = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (!$async$self.ptr.hasMore$0())
                throw B.wrapException(F.ChapterFormatException$("Empty BufferPtr sent to parsePtr", $async$self.debugId));
              $async$self.skipToHeaderSeparator$0();
              spans = $async$self.parseBodyAndCatchErrors$0();
              t1 = new A.Chapter(info, B._setArrayType([], type$.JSArray_Holder), $.$get$ChangeNotifier__emptyListeners());
              spans.listen$4$cancelOnError$onDone$onError(t1.get$_addHolderFromStream(), false, t1.get$postLoadCleanup(), t1.get$addAndRegisterError());
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$parseWithExistingChapterInfo$2$handleErrors, $async$completer);
    },
    parseBookHeader$1(index) {
      return this.parseBookHeader$body$ChapterParser(index);
    },
    parseBookHeader$body$ChapterParser(index) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.nullable_ChapterInfo),
        $async$returnValue, $async$self = this, t1, varName, displayName, filename, nextId;
      var $async$parseBookHeader$1 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self.ptr.assertConsume$2$debugId("(", "?");
              t1 = $async$self.ptr.consumeTypedInt$0();
              t1.toString;
              $async$self.ptr.assertConsume$2$debugId("=", "Chapter" + t1);
              varName = $async$self.ptr.consumeText$0();
              if (varName == null) {
                $async$returnValue = null;
                // goto return
                $async$goto = 1;
                break;
              }
              $async$self.ptr.assertConsume$2$debugId(":", varName);
              displayName = $async$self.ptr.consumeText$0();
              $async$self.ptr.assertConsume$2$debugId("@", varName);
              filename = $async$self.ptr.consumeText$0();
              if (filename == null) {
                $async$returnValue = null;
                // goto return
                $async$goto = 1;
                break;
              }
              $async$self.ptr.assertConsume$2$debugId(">", varName);
              nextId = $async$self.ptr.consumeTypedInt$0();
              $async$self.ptr.assertConsume$2$debugId("*", varName);
              $async$self.ptr.consumeUint32$0();
              $async$self.ptr.assertConsume$2$debugId(")", varName);
              $async$self.ptr.assertConsume$2$debugId(";", varName);
              $async$returnValue = new A.ChapterInfo(t1, displayName == null ? "[" + varName + "]" : displayName, filename, varName, nextId);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$parseBookHeader$1, $async$completer);
    },
    skipToHeaderSeparator$0() {
      var _this = this,
        finished = false;
      while (true) {
        if (!(!finished && _this.ptr.hasMore$0()))
          break;
        _this.ptr.consumeUntil$1(H.Codes_38_5_AMPERSAND);
        finished = _this.ptr.consumeIfAsciiString$1("zoinks&");
      }
      _this.ptr.consumeIf$1(D.Codes_10_0_NEWLINE);
    },
    parseBodyAndCatchErrors$0() {
      var $async$parseBodyAndCatchErrors$0 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        switch ($async$errorCode) {
          case 2:
            $async$next = $async$nextWhenCanceled;
            $async$goto = $async$next.pop();
            break;
          case 1:
            $async$errorStack.push($async$result);
            $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              errorCt = 0;
            case 3:
              // for condition
              if (!$async$self.ptr.hasMore$0()) {
                // goto after for
                $async$goto = 4;
                break;
              }
              $async$handler = 6;
              $async$goto = 9;
              $async$nextWhenCanceled = [1];
              return E._asyncStarHelper(E._IterationMarker_yieldSingle($async$self.readOneHolder$0()), $async$parseBodyAndCatchErrors$0, $async$controller);
            case 9:
              // after yield
              $async$handler = 2;
              // goto after finally
              $async$goto = 8;
              break;
            case 6:
              // catch
              $async$handler = 5;
              $async$exception = $async$errorStack.pop();
              excep = B.unwrapException($async$exception);
              trace = B.getTraceFromException($async$exception);
              J.toString$0$(excep);
              $async$goto = 10;
              $async$nextWhenCanceled = [1];
              return E._asyncStarHelper(E._IterationMarker_yieldSingle(new B.ExceptionHolder(excep, trace)), $async$parseBodyAndCatchErrors$0, $async$controller);
            case 10:
              // after yield
              if (errorCt >= 3) {
                // goto return
                $async$goto = 1;
                break;
              }
              ++errorCt;
              $async$self.ptr.consumeUntil$1(";");
              // goto after finally
              $async$goto = 8;
              break;
            case 5:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 8:
              // after finally
              // goto for condition
              $async$goto = 3;
              break;
            case 4:
              // after for
            case 1:
              // return
              return E._asyncStarHelper(null, 0, $async$controller);
            case 2:
              // rethrow
              return E._asyncStarHelper($async$errorStack.at(-1), 1, $async$controller);
          }
      });
      var $async$goto = 0,
        $async$controller = E._makeAsyncStarStreamController($async$parseBodyAndCatchErrors$0, type$.Holder),
        $async$nextWhenCanceled, $async$handler = 2, $async$errorStack = [], $async$next = [], $async$self = this, excep, trace, exception, errorCt, $async$exception;
      return E._streamOfController($async$controller);
    },
    parseHolders$0() {
      return new B._SyncStarIterable(this.parseHolders$body$ChapterParser(), type$._SyncStarIterable_Holder);
    },
    parseHolders$body$ChapterParser() {
      var $async$self = this;
      return function() {
        var $async$goto = 0, $async$handler = 1, $async$errorStack = [];
        return function $async$parseHolders$0($async$iterator, $async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$errorStack.push($async$result);
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
              case 2:
                // for condition
                if (!$async$self.ptr.hasMore$0()) {
                  // goto after for
                  $async$goto = 3;
                  break;
                }
                $async$goto = 4;
                return $async$iterator._async$_current = $async$self.readOneHolder$0(), 1;
              case 4:
                // after yield
                // goto for condition
                $async$goto = 2;
                break;
              case 3:
                // after for
                // implicit return
                return 0;
              case 1:
                // rethrow
                return $async$iterator._datum = $async$errorStack.at(-1), 3;
            }
        };
      };
    },
    readOneHolder$0() {
      var val, char, t2, text, height, trace, width, color, holder, t3, _this = this,
        t1 = new A.LiveFont(C.TextAlign_0),
        liveHolder = new A.LiveTextHolder(t1);
      for (; _this.ptr.hasMore$0();) {
        val = _this.ptr.consumeUint8$0();
        char = B.Primitives_stringFromCharCode(val);
        if (val === 0) {
          if (_this.ptr.hasMore$0())
            throw B.wrapException(F.ChapterFormatException$("Null terminator in middle of binary", _this.debugId));
        } else if (val !== 10)
          if (val === 59)
            return liveHolder.instantiate$0();
          else if (val === 123) {
            t2 = _this.ptr.consumeText$1$leadingQuoteAlreadyParsed(true);
            t2.toString;
            liveHolder.text = t2;
          } else if (val === 40)
            _this.ptr = t1.parseDecorations$1(_this.ptr);
          else if (char === "H") {
            text = _this.ptr.consumeText$0();
            if (text == null)
              throw B.wrapException(F.ChapterFormatException$("No text in header", _this.debugId));
            liveHolder.text = text;
            t2 = t1.parseFont$1(_this.ptr);
            _this.ptr = t2;
            t2.assertConsume$2$debugId(D.Codes_59_15_SEMICOLON, _this.debugId);
            return liveHolder.instantiateHeader$0();
          } else if (char === "S")
            return _this.parseMultiSpan$0();
          else if (char === "N") {
            height = _this.ptr.consumeFloat32$0();
            if (height > 2000) {
              t1 = _this.ptr.start;
              trace = B.StackTrace_current();
              trace.toString$0(0);
              $.$get$ErrorList_instance().list.push(new B.ExceptionHolder("Oversized newline in chapter " + _this.debugId + " binary " + B.S(height) + " (pos=" + t1, trace));
              height = 2000;
            }
            _this.ptr.consume$1(1);
            return new A.NewlineElement(height);
          } else if (char === "b") {
            width = _this.ptr.consumeFloat32$0();
            height = _this.ptr.consumeFloat32$0();
            color = _this.ptr.consumeColor$1$throwOnFail(true);
            return new A.ColoredBoxHolder(width, height, color == null ? C.Color_Edl : color);
          } else if (char === "P") {
            if (_this.ptr.consumeTypedChar$0() != null)
              return D.C_PageBreakOfText;
          } else if (char === "C") {
            holder = _this.getCustomCodeElement$1(D.CodeElementType_1);
            _this.ptr.assertConsume$2$debugId(D.Codes_59_15_SEMICOLON, _this.debugId);
            return holder;
          } else if (char === "T") {
            holder = _this.getCustomCodeElement$1(D.CodeElementType_2);
            _this.ptr.assertConsume$2$debugId(D.Codes_59_15_SEMICOLON, _this.debugId);
            return holder;
          } else if (char === "D") {
            holder = _this.getCustomCodeElement$1(D.CodeElementType_0);
            _this.ptr.assertConsume$2$debugId(D.Codes_59_15_SEMICOLON, _this.debugId);
            return holder;
          } else {
            t1 = C.JSString_methods.contains$1(")}]>", char);
            t2 = _this.debugId;
            t3 = _this.ptr.start;
            if (t1)
              throw B.wrapException(F.ChapterFormatException$("Unmatched paren " + char + " in chapter binary (pos=" + t3 + ")", t2));
            else
              throw B.wrapException(F.ChapterFormatException$("Unhandled char " + char + " (code=" + val + " pos=" + t3 + ") in chapter binary", t2));
          }
      }
      B.ErrorList_logError(new F.ChapterFormatException("Unterminated TextHolder (pos=" + _this.ptr.start + "; liveHolder=" + liveHolder.toString$0(0) + ")", _this.debugId), null);
      return liveHolder.instantiate$0();
    },
    parseMultiSpan$0() {
      var t2, t3, t4, braceLen, subPtr, holder, _this = this,
        t1 = B._setArrayType([], type$.JSArray_FragOfText),
        span = new A.LiveSpanOfText(t1, C.TextAlign_0);
      if (_this.ptr.consumeIf$1("(")) {
        _this.ptr.consumeInt32$0();
        span.tabs = _this.ptr.consumeUint8$0();
        span.align = A.stringToAlign(_this.ptr.consumeChar$0());
        if (!_this.ptr.consumeIf$1(")"))
          throw B.wrapException(F.ChapterFormatException$("Unmatched ( in ChapterFormat Span element; (found '" + _this.ptr.getChar$0() + " instead')", _this.debugId));
      }
      t2 = _this.ptr.consumeIf$1("[");
      t3 = _this.ptr;
      t4 = _this.debugId;
      if (t2) {
        braceLen = t3.consumeUint32$0();
        _this.ptr.assertConsume$2$debugId(".", t4);
        subPtr = _this.ptr.subset$2(0, braceLen);
        _this.ptr.consume$1(braceLen);
        _this.ptr.assertConsume$2$debugId("]", t4);
        while (true) {
          if (!(subPtr.hasMore$0() && !subPtr.consumeIf$1("]")))
            break;
          holder = _this.parseSpanFragment$2$ptr(span, subPtr);
          if (holder != null)
            t1.push(holder);
        }
      } else
        throw B.wrapException(F.ChapterFormatException$("No list in span. char=" + t3.getChar$0() + " pos=" + _this.ptr.start, t4));
      t1 = span.mapFunc$0();
      t1 = B.List_List$_of(t1, t1.$ti._eval$1("Iterable.E"));
      t1.$flags = 1;
      return new A.SpanOfText(t1, span.align, span.tabs);
    },
    parseSpanFragment$2$ptr(span, ptr) {
      var width, height, color, t2, fontData,
        t1 = new A.LiveFont(C.TextAlign_0),
        frag = new A.LiveFragment(t1);
      for (; ptr.hasMore$0();)
        if (ptr.consumeIf$1("b")) {
          width = this.ptr.consumeFloat32$0();
          height = this.ptr.consumeFloat32$0();
          color = this.ptr.consumeColor$1$throwOnFail(true);
          return new A.ColoredBoxFrag(width, height, color == null ? C.Color_Edl : color);
        } else if (ptr.consumeIf$1("{")) {
          t2 = ptr.consumeUntil$1(125).toIntList$0();
          frag.text = new B._Utf8Decoder(false)._convertGeneral$4(t2, 0, null, true);
        } else if (ptr.consumeIf$1("(")) {
          fontData = ptr.consumeUntil$2$includeChar(41, true);
          t1.fontId = fontData.consumeTypedInt$0();
          t1.size = fontData.consumeFloat32$0();
          t1.wousi = A.Wousi$fromByte(fontData.consumeUint8$0());
          if (fontData.consumeIf$1(H.Codes_38_5_AMPERSAND)) {
            t1.bgCol = fontData.consumeColor$1$throwOnFail(false);
            if (fontData.consumeIf$1(H.Codes_38_5_AMPERSAND))
              t1.fontCol = fontData.consumeColor$0();
          }
        } else if (ptr.consumeIf$1(";"))
          return frag;
        else if (ptr.getChar$0() === "]")
          throw B.wrapException(B.UnimplementedError$('"Not sure what to do about this" - ending bracket in span fragment'));
        else
          throw B.wrapException(F.ChapterFormatException$("Unhandled char in FragOfText " + ptr.getChar$0() + " " + ptr.start, "frag?"));
      return null;
    },
    getCustomCodeElement$1(type) {
      var n, t2, t3, binLen, secondPtr, _this = this,
        _s40_ = 'Missing open LBRK in CodeBlock (char = "',
        cls = _this.ptr.readUntil$1(58).toUpperCase(),
        t1 = type$.JSArray_String,
        params = B._setArrayType([], t1);
      if (_this.ptr.consumeIf$1(D.Codes_60_16_LGATOR))
        params = B._setArrayType(_this.ptr.readUntil$1(D.Codes_62_18_RGATOR).split(","), t1);
      for (t1 = params.length, n = 0; n < t1; ++n) {
        t2 = params[n];
        t3 = t2.length;
        if (t3 > 2)
          params[n] = C.JSString_methods.substring$2(t2, 1, t3 - 1);
        else
          params[n] = "";
      }
      if (type === D.CodeElementType_2)
        return new A.FutureHolder(A._instantiateCodeTag(cls, params));
      else if (type === D.CodeElementType_1) {
        if (!_this.ptr.consumeIf$1(D.Codes_91_23_LSQR))
          throw B.wrapException(F.ChapterFormatException$(_s40_ + _this.ptr.getChar$0() + '" pos=' + _this.ptr.start + ")", _this.debugId));
        binLen = _this.ptr.consumeUint32$0();
        t1 = _this.debugId;
        _this.ptr.assertConsume$2$debugId(".", t1);
        secondPtr = _this.ptr.subset$2(0, binLen);
        _this.ptr.consume$1(binLen);
        _this.ptr.assertConsume$2$debugId("]", t1);
        t1 = new A.ChapterParser(t1, secondPtr).parseHolders$0();
        t1 = B.List_List$_of(t1, t1.$ti._eval$1("Iterable.E"));
        t1.$flags = 1;
        return new A.FutureHolder(A._instantiateCodeBlock(cls, params, t1));
      } else if (type === D.CodeElementType_0) {
        if (!_this.ptr.consumeIf$1(H.Codes_123_28_LBRACE))
          throw B.wrapException(F.ChapterFormatException$(_s40_ + _this.ptr.getChar$0() + '" pos=' + _this.ptr.start + ")", _this.debugId));
        binLen = _this.ptr.consumeUint32$0();
        t1 = _this.debugId;
        _this.ptr.assertConsume$2$debugId(".", t1);
        secondPtr = _this.ptr.subset$2(0, binLen);
        _this.ptr.consume$1(binLen);
        _this.ptr.assertConsume$2$debugId(H.Codes_125_30_RBRACE, t1);
        return new A.FutureHolder(A._parseParsedBlock(cls, params, secondPtr));
      } else
        throw B.wrapException(D.DeveloperException_mQb);
    }
  };
  A.BookCodeException.prototype = {
    toString$0(_) {
      return "BookCodeException (Error from book's code markers): " + this.msg;
    },
    $isException: 1
  };
  A.FontException.prototype = {
    toString$0(_) {
      return "FontException: " + this.msg + " (" + B.S(this.family) + ")";
    },
    $isException: 1
  };
  A._LoadStatus.prototype = {
    _enumToString$0() {
      return "_LoadStatus." + this._name;
    }
  };
  A.FontFile.prototype = {
    load$0() {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.dynamic),
        $async$returnValue, $async$self = this, t1;
      var $async$load$0 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = $async$self._font_cache$_status === D._LoadStatus_0 ? 3 : 4;
              break;
            case 3:
              // then
              $async$self._font_cache$_status = D._LoadStatus_1;
              t1 = $async$self.cache;
              t1 = t1 == null ? null : t1.load$0().then$1$2$onError($async$self.get$_markLoaded(), $async$self.get$_downloadError(), type$.void);
              $async$goto = 5;
              return B._asyncAwait(type$.Future_void._is(t1) ? t1 : B._Future$value(t1, type$.void), $async$load$0);
            case 5:
              // returning from await.
            case 4:
              // join
              $async$returnValue = null;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$load$0, $async$completer);
    },
    _markLoaded$1(infos) {
      this._font_cache$_status = D._LoadStatus_2;
    },
    _downloadError$2(excep, trace) {
      L.ErrorList_showError(excep, trace);
      this._font_cache$_status = D._LoadStatus_3;
    }
  };
  A.FontCache.prototype = {
    builtinFontFamilies$1(id) {
      switch (id) {
        case 0:
          return "Palatino";
        case 1:
          return "Rubik";
      }
      return null;
    },
    getFontFile$1(id) {
      return this.getFontFile$body$FontCache(id);
    },
    getFontFile$body$FontCache(id) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.nullable_FontFile),
        $async$returnValue, $async$self = this, f, family, t1;
      var $async$getFontFile$1 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.files;
              $async$goto = t1.containsKey$1(id) ? 3 : 5;
              break;
            case 3:
              // then
              if (t1.$index(0, id) == null)
                throw B.wrapException(A.FontException$("Null FontFile in FontCache", "F" + id));
              $async$returnValue = t1.$index(0, id);
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$goto = id !== 0 && id !== 1 ? 6 : 8;
              break;
            case 6:
              // then
              $async$goto = 9;
              return B._asyncAwait(A.FontFile_fromId(id), $async$getFontFile$1);
            case 9:
              // returning from await.
              f = $async$result;
              t1.$indexSet(0, id, f);
              $async$returnValue = f;
              // goto return
              $async$goto = 1;
              break;
              // goto join
              $async$goto = 7;
              break;
            case 8:
              // else
              family = $async$self.builtinFontFamilies$1(id);
              family.toString;
              f = new A.FontFile(id, C.List_empty, family, D._LoadStatus_2, null);
              t1.$indexSet(0, id, f);
              $async$returnValue = f;
              // goto return
              $async$goto = 1;
              break;
            case 7:
              // join
            case 4:
              // join
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$getFontFile$1, $async$completer);
    }
  };
  A.FontInterm.prototype = {
    toString$0(_) {
      var _this = this;
      return "[id:" + _this.fileId + " size:" + B.S(_this.size) + " weight:" + B.S(_this.weight) + " ital:" + _this.italic + "]";
    },
    get$family() {
      var t1 = this.file;
      return t1 == null ? null : t1.family;
    },
    get$fileUrl() {
      var t1 = this.file;
      return t1 == null ? null : t1.urls;
    },
    loadStatus$0() {
      var t1 = this.file,
        t2 = t1 == null;
      t1 = t2 ? null : t1._font_cache$_status._name;
      if (t1 == null)
        t1 = t2 ? "Null file" : "Unfetched/Default";
      return t1;
    },
    load$0() {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.dynamic),
        $async$returnValue, $async$self = this, t1;
      var $async$load$0 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.file;
              $async$goto = t1 == null ? 4 : 6;
              break;
            case 4:
              // then
              $async$goto = 7;
              return B._asyncAwait($async$self.getFontFile$0(), $async$load$0);
            case 7:
              // returning from await.
              $async$result = $async$self.file = $async$result;
              // goto join
              $async$goto = 5;
              break;
            case 6:
              // else
              $async$result = t1;
            case 5:
              // join
              $async$goto = 3;
              return B._asyncAwait($async$result.load$0(), $async$load$0);
            case 3:
              // returning from await.
              t1 = $async$self.file;
              t1.toString;
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$load$0, $async$completer);
    },
    isLoaded$0() {
      var t1 = this.file;
      t1 = t1 == null ? null : t1._font_cache$_status === D._LoadStatus_2;
      return t1 === true;
    },
    instance$0() {
      var t3, _this = this, _null = null,
        t1 = A.FontCache_intToWeight(_this.weight),
        t2 = _this.color;
      if (t2 == null)
        t2 = C.Color_rOe;
      t3 = _this.file;
      t3 = t3 == null ? _null : t3.family;
      return B.TextStyle$(_null, _null, t2, _null, _null, _null, _null, _null, t3, _null, _null, _this.size * 2, _null, _null, t1, _null, _null, true, _null, _null, _null, _null, _null, _null, _null, _null);
    },
    fallback$0() {
      var _null = null,
        t1 = A.FontCache_intToWeight(this.weight),
        t2 = this.color;
      if (t2 == null)
        t2 = C.Color_rOe;
      return B.TextStyle$(_null, _null, t2, _null, _null, _null, _null, _null, "Palatino", _null, _null, this.size * 2, _null, _null, t1, _null, _null, true, _null, _null, _null, _null, _null, _null, _null, _null);
    },
    getFontFile$0() {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.nullable_FontFile),
        $async$returnValue, $async$self = this, t1;
      var $async$getFontFile$0 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.file;
              if (t1 == null) {
                t1 = $.FontCache__instance;
                if (t1 == null)
                  t1 = $.FontCache__instance = new A.FontCache(B.LinkedHashMap_LinkedHashMap$_empty(type$.int, type$.nullable_FontFile));
                $async$returnValue = t1.getFontFile$1($async$self.fileId);
                // goto return
                $async$goto = 1;
                break;
              }
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$getFontFile$0, $async$completer);
    }
  };
  A.Wousi.prototype = {
    isBasic$0() {
      var t2, _this = this,
        t1 = _this.__Wousi_weight_F;
      t1 === $ && B.throwUnnamedLateFieldNI();
      t2 = false;
      if (t1 === 500) {
        t1 = _this.__Wousi_italic_F;
        t1 === $ && B.throwUnnamedLateFieldNI();
        if (!t1) {
          t1 = _this.__Wousi_underline_F;
          t1 === $ && B.throwUnnamedLateFieldNI();
          if (!t1) {
            t1 = _this.__Wousi_overline_F;
            t1 === $ && B.throwUnnamedLateFieldNI();
            if (!t1) {
              t1 = _this.__Wousi_strikethrough_F;
              t1 === $ && B.throwUnnamedLateFieldNI();
              t1 = !t1;
            } else
              t1 = t2;
          } else
            t1 = t2;
        } else
          t1 = t2;
      } else
        t1 = t2;
      return t1;
    }
  };
  A.LiveFont.prototype = {
    isBody$0() {
      var t2, _this = this,
        t1 = false;
      if (_this.fontId === 0) {
        t2 = _this.size;
        if (t2 == null || t2 === 12)
          if (_this.bgCol == null)
            if (_this.fontCol == null) {
              t1 = _this.wousi;
              t1 = t1 == null ? null : t1.isBasic$0();
              t1 = t1 !== false;
            }
      }
      return t1;
    },
    parseFont$1(ptr) {
      var t1, _this = this;
      if (ptr.getChar$0() === ";") {
        _this.fontId = 0;
        _this.size = 12;
        _this.wousi = new A.Wousi(500, false, false, false, false);
        return ptr;
      } else {
        t1 = ptr.consumeTypedInt$0();
        t1.toString;
        _this.fontId = t1;
        _this.size = ptr.consumeFloat32$0();
        _this.wousi = A.Wousi$fromByte(ptr.consumeUint8$0());
        return ptr;
      }
    },
    parseDecorations$1(ptr) {
      var align, t1, t2, _this = this, _s4_ = "font",
        _s25_ = "Unexpected char in font (";
      _this.tabs = ptr.consumeUint8$0();
      align = ptr.consumeChar$0();
      t1 = ptr.start;
      if (align === "l")
        _this.align = C.TextAlign_0;
      else if (align === "c")
        _this.align = C.TextAlign_2;
      else if (align === "r")
        _this.align = C.TextAlign_1;
      else if (align === "j")
        _this.align = C.TextAlign_3;
      else {
        _this.align = C.TextAlign_0;
        t2 = B.CodeUnits$(align);
        B.throwExpression(F.ChapterFormatException$('Unrecognized alignment char "' + align + '" (=' + t2.toString$0(t2) + ") @pos=" + t1, "?"));
      }
      ptr.hasMore$0();
      if (ptr.eatRParen$0())
        return ptr;
      else if (ptr.eatAmpersand$0()) {
        ptr = _this.parseFont$1(ptr);
        if (ptr.eatRParen$0())
          return ptr;
        else if (ptr.eatAmpersand$0()) {
          _this.bgCol = ptr.consumeColor$1$throwOnFail(true);
          if (ptr.eatRParen$0())
            return ptr;
          else if (ptr.eatAmpersand$0()) {
            _this.fontCol = ptr.consumeColor$1$throwOnFail(true);
            if (ptr.eatRParen$0())
              return ptr;
            else
              throw B.wrapException(F.ChapterFormatException$("Unexpected char at end of font (" + ptr.getChar$1(0) + " pos=" + ptr.start + " [L4])", _s4_));
          } else
            throw B.wrapException(F.ChapterFormatException$(_s25_ + ptr.getChar$1(0) + " pos=" + ptr.start + " [L3])", _s4_));
        } else
          throw B.wrapException(F.ChapterFormatException$(_s25_ + ptr.getChar$1(0) + " pos=" + ptr.start + " [L2])", _s4_));
      } else
        throw B.wrapException(F.ChapterFormatException$(_s25_ + ptr.getChar$1(0) + " pos=" + ptr.start + " [L1])", _s4_));
    },
    convertToFontInterm$0() {
      var t2, t3, t4, t5, _this = this,
        t1 = _this.fontId;
      if (t1 == null)
        t1 = 0;
      t2 = _this.size;
      if (t2 == null)
        t2 = 12;
      t3 = _this.wousi;
      t4 = t3 == null;
      if (t4)
        t5 = null;
      else {
        t5 = t3.__Wousi_italic_F;
        t5 === $ && B.throwUnnamedLateFieldNI();
      }
      if (t4)
        t3 = null;
      else {
        t3 = t3.__Wousi_weight_F;
        t3 === $ && B.throwUnnamedLateFieldNI();
      }
      return new A.FontInterm(t1, t2, t5 === true, t3, _this.fontCol);
    }
  };
  A.LiveTextHolder.prototype = {
    instantiate$0() {
      var t2, t3, f, t4, _this = this,
        t1 = _this.font;
      if (t1.isBody$0()) {
        t2 = t1.align;
        if (t2 !== C.TextAlign_0 || t1.tabs > 0) {
          t3 = _this.text;
          return new A.AlignedBodyText(t2, t1.tabs, t3);
        }
        return new A.BodyTextElement(_this.text);
      } else if (t1.bgCol != null) {
        f = t1.convertToFontInterm$0();
        t2 = _this.text;
        t3 = t1.bgCol;
        if (t3 == null)
          t3 = C.Color_xen;
        t4 = t1.tabs;
        return new A.HiliteFontText(t1.align, t3, t4, f, t2);
      } else {
        f = t1.convertToFontInterm$0();
        t2 = _this.text;
        t3 = t1.tabs;
        return new A.CustomFontText(t1.align, t3, f, t2);
      }
    },
    instantiateHeader$0() {
      var t3,
        t1 = this.font,
        t2 = false;
      if (t1.fontId === 1) {
        t3 = t1.size;
        if (t3 == null || t3 === 24)
          if (t1.bgCol == null)
            if (t1.fontCol == null) {
              t2 = t1.wousi;
              t2 = t2 == null ? null : t2.isBasic$0();
              t2 = t2 !== false;
            }
      }
      t3 = this.text;
      if (t2)
        return new A.HeaderOfText(t3);
      else {
        t2 = t1.convertToFontInterm$0();
        return new A.CustomHeaderOfText(t1.align, t2, t3);
      }
    }
  };
  A.LiveFragment.prototype = {
    span$1(context) {
      return D.WidgetSpan_uDf;
    },
    convert$0() {
      var t1 = this.font;
      if (t1.isBody$0())
        return new A.FragBody(this.text);
      else
        return new A.FragCustom(t1.convertToFontInterm$0(), this.text);
    }
  };
  A.LiveSpanOfText.prototype = {
    mapFunc$0() {
      return new B._SyncStarIterable(this.mapFunc$body$LiveSpanOfText(), type$._SyncStarIterable_FragOfText);
    },
    mapFunc$body$LiveSpanOfText() {
      var $async$self = this;
      return function() {
        var $async$goto = 0, $async$handler = 1, $async$errorStack = [], t1, t2, _i, frag;
        return function $async$mapFunc$0($async$iterator, $async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$errorStack.push($async$result);
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.lines, t2 = t1.length, _i = 0;
              case 2:
                // for condition
                if (!(_i < t1.length)) {
                  // goto after for
                  $async$goto = 4;
                  break;
                }
                frag = t1[_i];
                $async$goto = frag instanceof A.LiveFragment ? 5 : 7;
                break;
              case 5:
                // then
                $async$goto = 8;
                return $async$iterator._async$_current = frag.convert$0(), 1;
              case 8:
                // after yield
                // goto join
                $async$goto = 6;
                break;
              case 7:
                // else
                $async$goto = 9;
                return $async$iterator._async$_current = frag, 1;
              case 9:
                // after yield
              case 6:
                // join
              case 3:
                // for update
                t1.length === t2 || (0, B.throwConcurrentModificationError)(t1), ++_i;
                // goto for condition
                $async$goto = 2;
                break;
              case 4:
                // after for
                // implicit return
                return 0;
              case 1:
                // rethrow
                return $async$iterator._datum = $async$errorStack.at(-1), 3;
            }
        };
      };
    },
    element$1(context) {
      return I.CircularProgressIndicator_null_null;
    },
    fallback$1(context) {
      return I.CircularProgressIndicator_null_null;
    }
  };
  A.CodeElementType.prototype = {
    _enumToString$0() {
      return "CodeElementType." + this._name;
    }
  };
  A.UnhandledCodeElement.prototype = {
    element$1(context) {
      var t1 = this.classname;
      return M.ColoredIconCard$(null, "[Needs code element: " + t1 + " (" + this.category + ")]", D.IconData_57737_MaterialIcons_null_false, t1.toLowerCase());
    },
    fallback$1(context) {
      var t1 = this.classname;
      return M.ColoredIconCard$(null, "[Needs code element: " + t1 + " (" + this.category + ")*]", D.IconData_58258_MaterialIcons_null_false, t1.toLowerCase());
    }
  };
  A.FutureHolder.prototype = {
    element$1(context) {
      return new B.FutureBuilder(this.holder, this.get$futureBuilder(), new B.ValueKey("FH_" + B.Primitives_objectHashCode(this), type$.ValueKey_String), type$.FutureBuilder_Holder);
    },
    futureBuilder$2(context, snapshot) {
      var t2,
        t1 = snapshot.data;
      if (t1 != null)
        return t1.element$1(context);
      else {
        t1 = snapshot.error;
        if (t1 != null) {
          t2 = snapshot.stackTrace;
          return new B.ExceptionElement(t1, t2 == null ? "[no trace" : t2, null);
        } else
          return D.SizedBox_ldY0;
      }
    },
    fallback$1(context) {
      return new B.FutureBuilder(this.holder, this.get$fallbackFutureBuilder(), null, type$.FutureBuilder_Holder);
    },
    fallbackFutureBuilder$2(context, snapshot) {
      var t2,
        t1 = snapshot.data;
      if (t1 != null)
        return t1.fallback$1(context);
      else {
        t1 = snapshot.error;
        if (t1 != null) {
          t2 = snapshot.stackTrace;
          return new B.ExceptionElement(t1, t2 == null ? "[no trace" : t2, null);
        } else
          return D.SizedBox_ldY;
      }
    }
  };
  A.NewlineElement.prototype = {
    element$1(context) {
      return new B.SizedBox(null, this.height, null, null);
    },
    fallback$1(context) {
      return new B.SizedBox(null, this.height, null, null);
    }
  };
  A.ColoredBoxHolder.prototype = {
    element$1(context) {
      var _this = this, _null = null,
        t1 = _this.color;
      if (t1.a < 40)
        return B.Container$(_null, _null, C.Clip_0, _null, new B.BoxDecoration(t1, _null, B.Border_Border$all(C.Color_wst, -1, 1), _null, _null, _null, C.BoxShape_0), _this.height, C.EdgeInsets_0_0_0_0, C.EdgeInsets_0_0_0_0, _this.width);
      return B.Container$(_null, _null, C.Clip_0, t1, _null, _this.height, C.EdgeInsets_0_0_0_0, C.EdgeInsets_0_0_0_0, _this.width);
    },
    fallback$1(context) {
      return this.element$1(context);
    }
  };
  A.ColoredBoxFrag.prototype = {
    _misc_holders$_element$1(context) {
      var _this = this, _null = null,
        t1 = _this.color;
      if (t1.a < 40)
        return B.Container$(_null, _null, C.Clip_0, _null, new B.BoxDecoration(t1, _null, B.Border_Border$all(C.Color_wst, -1, 1), _null, _null, _null, C.BoxShape_0), _this.height, C.EdgeInsets_0_0_0_0, C.EdgeInsets_0_0_0_0, _this.width);
      return B.Container$(_null, _null, C.Clip_0, t1, _null, _this.height, C.EdgeInsets_0_0_0_0, C.EdgeInsets_0_0_0_0, _this.width);
    },
    span$1(context) {
      return B.WidgetSpan$(this._misc_holders$_element$1(context));
    },
    fallback$1(context) {
      return B.WidgetSpan$(this._misc_holders$_element$1(context));
    },
    isLoaded$0() {
      return true;
    }
  };
  A.PageBreakOfText.prototype = {
    element$1(context) {
      return D.SizedBox_null_240_null_null;
    },
    fallback$1(context) {
      return D.SizedBox_null_240_null_null;
    }
  };
  A.SpanOfText.prototype = {
    load$0() {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.dynamic),
        $async$returnValue, $async$self = this, t1, t2, _i, span;
      var $async$load$0 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.spans, t2 = t1.length, _i = 0;
            case 3:
              // for condition
              if (!(_i < t1.length)) {
                // goto after for
                $async$goto = 5;
                break;
              }
              span = t1[_i];
              $async$goto = !span.isLoaded$0() ? 6 : 7;
              break;
            case 6:
              // then
              $async$goto = 8;
              return B._asyncAwait(span.load$0(), $async$load$0);
            case 8:
              // returning from await.
            case 7:
              // join
            case 4:
              // for update
              t1.length === t2 || (0, B.throwConcurrentModificationError)(t1), ++_i;
              // goto for condition
              $async$goto = 3;
              break;
            case 5:
              // after for
              $async$returnValue = null;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$load$0, $async$completer);
    },
    isLoaded$0() {
      var t1, t2, _i;
      for (t1 = this.spans, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, B.throwConcurrentModificationError)(t1), ++_i)
        if (!t1[_i].isLoaded$0())
          return false;
      return true;
    },
    element$1(context) {
      var t3, n, _null = null,
        t1 = this.align,
        t2 = B._setArrayType([], type$.JSArray_InlineSpan);
      for (t3 = this.spans, n = 0; n < t3.length; ++n)
        t2.push(t3[n].span$1(context));
      return A.wrapInTabs(this.tabs, t1, B.RichText$(_null, _null, _null, C.TextOverflow_0, _null, _null, true, _null, B.TextSpan$(t2, _null, _null), t1, _null, _null, C._LinearTextScaler_1, C.TextWidthBasis_0));
    },
    fallback$1(context) {
      var t3, n, _null = null,
        t1 = this.align,
        t2 = B._setArrayType([], type$.JSArray_InlineSpan);
      for (t3 = this.spans, n = 0; n < t3.length; ++n)
        t2.push(t3[n].fallback$1(context));
      return A.wrapInTabs(this.tabs, t1, B.RichText$(_null, _null, _null, C.TextOverflow_0, _null, _null, true, _null, B.TextSpan$(t2, _null, _null), t1, _null, _null, C._LinearTextScaler_1, C.TextWidthBasis_0));
    }
  };
  A.FragOfText.prototype = {
    load$0() {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.dynamic),
        $async$returnValue;
      var $async$load$0 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = null;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$load$0, $async$completer);
    },
    isLoaded$0() {
      return true;
    },
    fallback$1(context) {
      return this.span$1(context);
    }
  };
  A.FragBody.prototype = {
    span$1(context) {
      return B.TextSpan$(null, C.TextStyle_ddR, this.text);
    }
  };
  A.FragCustom.prototype = {
    load$0() {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.dynamic),
        $async$returnValue, $async$self = this;
      var $async$load$0 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = $async$self.font.load$0();
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$load$0, $async$completer);
    },
    isLoaded$0() {
      return this.font.isLoaded$0();
    },
    span$1(context) {
      return B.TextSpan$(null, this.font.instance$0(), this.text);
    },
    fallback$1(context) {
      return B.TextSpan$(null, this.font.fallback$0(), this.text);
    }
  };
  A.UnhandledSpanHoldingCode.prototype = {};
  A.TextHolder.prototype = {};
  A.BodyTextElement.prototype = {
    element$1(context) {
      var _null = null;
      return B.Text$(this.text, _null, _null, _null, _null, C.TextStyle_ddR, _null, _null);
    },
    fallback$1(context) {
      var _null = null;
      return B.Text$(this.text, _null, _null, _null, _null, C.TextStyle_ddR, _null, _null);
    }
  };
  A.FontWanterTextHolder.prototype = {
    load$0() {
      return this.font.load$0();
    },
    isLoaded$0() {
      return this.font.isLoaded$0();
    }
  };
  A.AlignedBodyText.prototype = {
    element$1(context) {
      var _null = null,
        t1 = this.align;
      return A.wrapInTabs(this.tabs, t1, B.Text$(this.text, _null, _null, _null, _null, C.TextStyle_ddR, t1, _null));
    },
    fallback$1(context) {
      return this.element$1(context);
    }
  };
  A.HeaderOfText.prototype = {
    element$1(context) {
      var _null = null;
      return B.Container$(C.Alignment_0_0, B.Text$(this.text, _null, _null, _null, _null, C.TextStyle_fky.copyWith$5$color$decoration$decorationColor$fontSize$fontWeight(D.Color_rsC, C.TextDecoration_1, D.Color_rsC, 24, C.FontWeight_4_500), C.TextAlign_2, _null), C.Clip_0, Q.Color_Za3, _null, 36, _null, _null, _null);
    },
    fallback$1(context) {
      var _null = null;
      return B.Container$(C.Alignment_0_0, B.Text$(this.text, _null, _null, _null, _null, C.TextStyle_fky.copyWith$5$color$decoration$decorationColor$fontSize$fontWeight(D.Color_rsC, C.TextDecoration_1, D.Color_rsC, 24, C.FontWeight_4_500), C.TextAlign_2, _null), C.Clip_0, Z.Color_lrU, _null, 36, _null, _null, _null);
    }
  };
  A.HiddenTextElement.prototype = {
    element$1(context) {
      return C.SizedBox_0_0_null_null;
    },
    fallback$1(context) {
      return C.SizedBox_0_0_null_null;
    }
  };
  A.CustomFontText.prototype = {
    element$1(context) {
      var _this = this, _null = null,
        t1 = _this.align;
      return A.wrapInTabs(_this.tabs, t1, B.Text$(_this.text, _null, _null, _null, _null, _this.font.instance$0(), t1, _null));
    },
    fallback$1(context) {
      var _this = this, _null = null,
        t1 = _this.align;
      return A.wrapInTabs(_this.tabs, t1, B.Text$(_this.text, _null, _null, _null, _null, _this.font.fallback$0(), t1, _null));
    }
  };
  A.HiliteFontText.prototype = {
    element$1(context) {
      var t7, _this = this, _null = null,
        t1 = _this.tabs,
        t2 = _this.align,
        t3 = C.JSString_methods.$mul("\t", t1),
        t4 = _this.font,
        t5 = A.FontCache_intToWeight(t4.weight),
        t6 = t4.color;
      if (t6 == null)
        t6 = C.Color_rOe;
      t7 = t4.file;
      t7 = t7 == null ? _null : t7.family;
      return A.wrapInTabs(t1, t2, B.Text$(t3 + _this.text, _null, _null, _null, _null, B.TextStyle$(_null, _this.color, t6, _null, _null, _null, _null, _null, t7, _null, _null, t4.size * 2, _null, _null, t5, _null, _null, true, _null, _null, _null, _null, _null, _null, _null, _null), t2, _null));
    },
    fallback$1(context) {
      var _this = this, _null = null,
        t1 = _this.tabs,
        t2 = _this.align,
        t3 = C.JSString_methods.$mul("\t", t1),
        t4 = _this.font,
        t5 = A.FontCache_intToWeight(t4.weight),
        t6 = t4.color;
      if (t6 == null)
        t6 = C.Color_rOe;
      return A.wrapInTabs(t1, t2, B.Text$(t3 + _this.text, _null, _null, _null, _null, B.TextStyle$(_null, _this.color, t6, _null, _null, _null, _null, _null, "Rubik", _null, _null, t4.size * 2, _null, _null, t5, _null, _null, true, _null, _null, _null, _null, _null, _null, _null, _null), t2, _null));
    }
  };
  A.CustomHeaderOfText.prototype = {
    element$1(context) {
      var _null = null,
        t1 = B.Border_Border$all(D.Color_xMg, -1, 1),
        t2 = this.align;
      return B.Container$(_null, new B.Align(A.textAlignToHoriz(t2), _null, _null, B.Text$(this.text, _null, _null, _null, _null, this.font.instance$0(), t2, _null), _null), C.Clip_0, _null, new B.BoxDecoration(_null, _null, t1, _null, _null, _null, C.BoxShape_0), _null, _null, _null, _null);
    },
    fallback$1(context) {
      return this.super$HeaderOfText$fallback(context);
    }
  };
  A.RNG.prototype = {};
  A.CryptoRNG.prototype = {
    _generateInternal$0() {
      var i, k,
        b = new Uint8Array(16);
      for (i = 0; i < 16; i += 4) {
        k = $.$get$CryptoRNG__secureRandom().nextInt$1(C.JSNumber_methods.toInt$0(Math.pow(2, 32)));
        b[i] = k;
        b[i + 1] = C.JSInt_methods._shrOtherPositive$1(k, 8);
        b[i + 2] = C.JSInt_methods._shrOtherPositive$1(k, 16);
        b[i + 3] = C.JSInt_methods._shrOtherPositive$1(k, 24);
      }
      return b;
    }
  };
  A.Uuid.prototype = {
    v1$0() {
      return new A.UuidV1(null).generate$1$options(null);
    }
  };
  A.UuidV1.prototype = {
    _init$0() {
      if ($.V1State_initialized)
        return;
      var uint8list = $.$get$V1State_random()._generateInternal$0();
      $.V1State_nodeId = B._setArrayType([uint8list[0] | 1, uint8list[1], uint8list[2], uint8list[3], uint8list[4], uint8list[5]], type$.JSArray_int);
      $.V1State_clockSeq = (uint8list[6] << 8 | uint8list[7]) & 262143;
      $.V1State_initialized = true;
    },
    generate$1$options(options) {
      var buf, clockSeq, mSecs, t1, nSecs, t2, tl, tmh, node, n;
      this._init$0();
      buf = new Uint8Array(16);
      clockSeq = $.V1State_clockSeq;
      mSecs = Date.now();
      t1 = $.V1State_nSecs;
      nSecs = t1 + 1;
      t2 = $.V1State_mSecs;
      t1 = mSecs - t2 + (nSecs - t1) / 10000 < 0;
      if (t1)
        clockSeq = clockSeq + 1 & 16383;
      t1 = t1 || mSecs > t2;
      if (t1)
        nSecs = 0;
      if (nSecs >= 10000)
        throw B.wrapException(B.Exception_Exception("uuid.v1(): Can't create more than 10M uuids/sec"));
      $.V1State_mSecs = mSecs;
      $.V1State_nSecs = nSecs;
      $.V1State_clockSeq = clockSeq;
      mSecs += 122192928e5;
      tl = ((mSecs & 268435455) * 10000 + nSecs) % 4294967296;
      buf[0] = tl >>> 24 & 255;
      buf[1] = tl >>> 16 & 255;
      buf[2] = tl >>> 8 & 255;
      buf[3] = tl & 255;
      tmh = C.JSNumber_methods.floor$0(mSecs / 4294967296 * 10000) & 268435455;
      buf[4] = tmh >>> 8 & 255;
      buf[5] = tmh & 255;
      buf[6] = tmh >>> 24 & 255;
      buf[7] = tmh >>> 16 & 255;
      buf[8] = clockSeq >>> 8 & 63;
      buf[9] = clockSeq & 255;
      buf[6] = buf[6] & 15 | 16;
      buf[8] = buf[8] | 128;
      node = $.V1State_nodeId;
      for (n = 0; n < 6; ++n)
        buf[10 + n] = node[n];
      t1 = $.$get$UuidParsing__byteToHex();
      return t1[buf[0]] + t1[buf[1]] + t1[buf[2]] + t1[buf[3]] + "-" + t1[buf[4]] + t1[buf[5]] + "-" + t1[buf[6]] + t1[buf[7]] + "-" + t1[buf[8]] + t1[buf[9]] + "-" + t1[buf[10]] + t1[buf[11]] + t1[buf[12]] + t1[buf[13]] + t1[buf[14]] + t1[buf[15]];
    }
  };
  var typesOffset = hunkHelpers.updateTypes(["int(_Codes)", "~(Object?)", "~()", "Future<int>()", "Node?(DirectoryNode,String,Node?)", "~(Object,StackTrace)", "Widget(BuildContext,AsyncSnapshot<Holder>)", "_Directory(Object?)", "_File(FileSystemEntity)", "_File(Object?)", "bool(FileInfo)", "~(FileInfo)", "DirectoryNode?(DirectoryNode,bool)", "RealNode?(DirectoryNode,bool)", "FileNode()", "~(FileNode)", "FileNode(FileNode)", "~(Node)", "Node?(DirectoryNode,String,Node?,int,int)", "bool(FileResponse)", "CacheInfoRepository(bool)", "Future<Null>(CacheObject?)", "Future<Response>(Client)", "~(Holder)", "~(Object[StackTrace?])", "~(Iterable<FileInfo>)", "~(@,@)", "~(String,FileSystemOp)", "bool(String)", "DateTime()"]);
  A._HeaderValue_toString_closure.prototype = {
    call$2($name, value) {
      var t3, start, i, codeUnit,
        t1 = this.sb,
        t2 = (t1._contents += "; ") + $name;
      t1._contents = t2;
      if (value != null) {
        t1._contents = t2 + "=";
        t2 = A._HeaderValue__isToken(value);
        t3 = t1._contents;
        if (t2)
          t1._contents = t3 + value;
        else {
          t1._contents = t3 + '"';
          for (t2 = value.length, start = 0, i = 0; i < t2; ++i) {
            codeUnit = value.charCodeAt(i);
            if (codeUnit === 92 || codeUnit === 34) {
              t1._contents = (t1._contents += C.JSString_methods.substring$2(value, start, i)) + "\\";
              start = i;
            }
          }
          t1._contents = (t1._contents += C.JSString_methods.substring$1(value, start)) + '"';
        }
      }
    },
    $signature: 206
  };
  A._HeaderValue__parse_done.prototype = {
    call$0() {
      return this._box_0.index === this.s.length;
    },
    $signature: 43
  };
  A._HeaderValue__parse_skipWS.prototype = {
    call$0() {
      var t1, t2, t3, t4, t5;
      for (t1 = this.done, t2 = this._box_0, t3 = this.s; !t1.call$0();) {
        t4 = t2.index;
        t5 = t3[t4];
        if (t5 !== " " && t5 !== "\t")
          return;
        t2.index = t4 + 1;
      }
    },
    $signature: 0
  };
  A._HeaderValue__parse_parseValue.prototype = {
    call$0() {
      var t2, t3, t4, t5, char, t6, _this = this,
        t1 = _this._box_0,
        start = t1.index;
      for (t2 = _this.done, t3 = _this.s, t4 = _this.parameterSeparator; !t2.call$0();) {
        t5 = t1.index;
        char = t3[t5];
        t6 = true;
        if (char !== " ")
          if (char !== "\t")
            t6 = char === t4;
        if (t6)
          break;
        t1.index = t5 + 1;
      }
      return C.JSString_methods.substring$2(t3, start, t1.index);
    },
    $signature: 14
  };
  A._HeaderValue__parse_expect.prototype = {
    call$1(expected) {
      var _this = this;
      if (_this.done.call$0() || _this.s[_this._box_0.index] !== expected)
        throw B.wrapException(A.HttpException$("Failed to parse header value", null));
      ++_this._box_0.index;
    },
    $signature: 50
  };
  A._HeaderValue__parse_maybeExpect.prototype = {
    call$1(expected) {
      var _this = this;
      if (_this.done.call$0() || !C.JSString_methods.startsWith$2(_this.s, expected, _this._box_0.index))
        return false;
      ++_this._box_0.index;
      return true;
    },
    $signature: 39
  };
  A._HeaderValue__parse_parseParameters.prototype = {
    call$0() {
      var t2, t3, t4, parseParameterName, parseParameterValue, t5, $name, value, _this = this,
        t1 = _this.$this,
        parameters = t1._parameters;
      if (parameters == null)
        parameters = t1._parameters = B.LinkedHashMap_LinkedHashMap$_empty(type$.String, type$.nullable_String);
      t1 = _this._box_0;
      t2 = _this.done;
      t3 = _this.s;
      t4 = _this.parameterSeparator;
      parseParameterName = new A._HeaderValue__parse_parseParameters_parseParameterName(t1, t2, t3, t4, _this.valueSeparator);
      parseParameterValue = new A._HeaderValue__parse_parseParameters_parseParameterValue(t1, t2, t3, _this.preserveBackslash, _this.parseValue);
      for (t1 = _this.expect, t3 = _this.maybeExpect, t5 = _this.skipWS; !t2.call$0();) {
        t5.call$0();
        if (t2.call$0())
          return;
        $name = parseParameterName.call$0();
        t5.call$0();
        if (t3.call$1("=")) {
          t5.call$0();
          value = parseParameterValue.call$0();
          parameters.$indexSet(0, $name, $name === "charset" ? value.toLowerCase() : value);
          t5.call$0();
        } else if ($name.length !== 0)
          parameters.$indexSet(0, $name, null);
        if (t2.call$0())
          return;
        t1.call$1(t4);
      }
    },
    $signature: 0
  };
  A._HeaderValue__parse_parseParameters_parseParameterName.prototype = {
    call$0() {
      var t2, t3, t4, t5, char, t6, _this = this,
        t1 = _this._box_0,
        start = t1.index;
      for (t2 = _this.done, t3 = _this.s, t4 = _this.parameterSeparator; !t2.call$0();) {
        t5 = t1.index;
        char = t3[t5];
        t6 = true;
        if (char !== " ")
          if (char !== "\t")
            if (char !== "=")
              t6 = char === t4;
        if (t6)
          break;
        t1.index = t5 + 1;
      }
      return C.JSString_methods.substring$2(t3, start, t1.index).toLowerCase();
    },
    $signature: 14
  };
  A._HeaderValue__parse_parseParameters_parseParameterValue.prototype = {
    call$0() {
      var t2, t3, t4, t5, t6, char, _this = this,
        _s28_ = "Failed to parse header value",
        t1 = _this.done;
      if (!t1.call$0() && _this.s[_this._box_0.index] === '"') {
        t2 = _this._box_0;
        ++t2.index;
        for (t3 = _this.s, t4 = t3.length, t5 = ""; !t1.call$0();) {
          t6 = t2.index;
          char = t3[t6];
          if (char === "\\") {
            ++t6;
            if (t6 === t4)
              throw B.wrapException(A.HttpException$(_s28_, null));
            t2.index = t6;
          } else if (char === '"') {
            t2.index = t6 + 1;
            return t5.charCodeAt(0) == 0 ? t5 : t5;
          }
          t5 += t3[t6];
          t2.index = t6 + 1;
        }
        throw B.wrapException(A.HttpException$(_s28_, null));
      } else
        return _this.parseValue.call$0();
    },
    $signature: 14
  };
  A.Future_Future$microtask_closure.prototype = {
    call$0() {
      var e, s, exception, t1, t2, t3, computationResult = null;
      try {
        computationResult = this.computation.call$0();
      } catch (exception) {
        e = B.unwrapException(exception);
        s = B.getTraceFromException(exception);
        t1 = e;
        t2 = s;
        t3 = B._interceptError(t1, t2);
        t1 = new B.AsyncError(t1, t2);
        this.result._completeErrorObject$1(t1);
        return;
      }
      this.result._complete$1(computationResult);
    },
    $signature: 0
  };
  A._MultiStream_listen_closure.prototype = {
    call$0() {
      this.$this._onListen.call$1(this.controller);
    },
    $signature: 0
  };
  A.HashMap_HashMap$from_closure.prototype = {
    call$2(k, v) {
      this.result.$indexSet(0, this.K._as(k), this.V._as(v));
    },
    $signature: 118
  };
  A._Directory__delete_closure.prototype = {
    call$1(response) {
      var t1 = this.$this;
      A._checkForErrorResponse(response, "Deletion failed", t1._io$_path);
      return t1;
    },
    $signature: typesOffset + 7
  };
  A._File__delete_closure.prototype = {
    call$1(__wc0_formal) {
      return this.$this;
    },
    $signature: typesOffset + 8
  };
  A._File__delete_closure0.prototype = {
    call$1(response) {
      var t1 = this.$this;
      A._checkForErrorResponse(response, "Cannot delete file", t1._io$_path);
      return t1;
    },
    $signature: typesOffset + 9
  };
  A._File_length_closure.prototype = {
    call$1(response) {
      A._checkForErrorResponse(response, "Cannot retrieve length of file", this.$this._io$_path);
      return response;
    },
    $signature: 84
  };
  A.DynamicCachedFonts_load_closure.prototype = {
    call$1(url) {
      return this.$call$body$DynamicCachedFonts_load_closure(url);
    },
    $call$body$DynamicCachedFonts_load_closure(url) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.String),
        $async$returnValue;
      var $async$call$1 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = url;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: 556
  };
  A.DynamicCachedFonts_load_closure0.prototype = {
    call$1(font) {
      return font.validTill.isBefore$1(new B.DateTime(Date.now(), 0, false));
    },
    $signature: typesOffset + 10
  };
  A.DynamicCachedFonts_load_closure1.prototype = {
    call$1(font) {
      return A.RawDynamicCachedFonts_cacheFont(font.originalUrl, this.$this.cacheStalePeriod, 200);
    },
    $signature: typesOffset + 11
  };
  A._FontFileExtensionManager_matchesFileExtension_closure.prototype = {
    call$1(magicNumber) {
      return B.listEquals(this.headerBytes, magicNumber);
    },
    $signature: 557
  };
  A.MemoryDirectory_createSync_closure.prototype = {
    call$2($parent, isFinalSegment) {
      if (this.recursive || isFinalSegment)
        return A.DirectoryNode$($parent);
      return null;
    },
    $signature: typesOffset + 12
  };
  A.MemoryDirectory_createTempSync_closure.prototype = {
    call$0() {
      return this.dirname;
    },
    $signature: 14
  };
  A.MemoryDirectory_createTempSync_closure0.prototype = {
    call$0() {
      return this.dirname;
    },
    $signature: 14
  };
  A.MemoryDirectory_createTempSync_name.prototype = {
    call$0() {
      return this.basename + this._box_0.tempCounter;
    },
    $signature: 14
  };
  A.MemoryFile__resolvedBackingOrCreate_closure.prototype = {
    call$0() {
      return this.$this.path;
    },
    $signature: 14
  };
  A.MemoryFile__resolvedBackingOrCreate_closure0.prototype = {
    call$0() {
      return this.$this.path;
    },
    $signature: 14
  };
  A.MemoryFile__doCreate_closure.prototype = {
    call$2($parent, isFinalSegment) {
      var t1;
      if (isFinalSegment) {
        t1 = new A.FileNode(new Uint8Array(0), $parent);
        t1.RealNode$1($parent);
        return t1;
      }
      return null;
    },
    $signature: typesOffset + 13
  };
  A._FileSink__FileSink$fromFile_closure.prototype = {
    call$0() {
      var t2, t3,
        t1 = this._box_0.deferredException;
      if (t1 != null)
        throw B.wrapException(t1);
      t1 = this.node;
      t2 = t1._readLocal$0();
      t3 = this.mode;
      if (t3 === D.C_FileMode || t3 === D.C_FileMode0)
        t2._content = new Uint8Array(0);
      return t1._readLocal$0();
    },
    $signature: typesOffset + 14
  };
  A._FileSink_addStream_closure.prototype = {
    call$1(data) {
      return this.$this._addData$1(data);
    },
    $signature: 217
  };
  A._FileSink_addStream_closure1.prototype = {
    call$2(error, stackTrace) {
      var t1 = this.$this;
      t1._streamCompleter.completeError$2(error, stackTrace);
      t1._streamCompleter = null;
    },
    $signature: 51
  };
  A._FileSink_addStream_closure0.prototype = {
    call$0() {
      var t1 = this.$this;
      t1._streamCompleter.complete$0();
      t1._streamCompleter = null;
    },
    $signature: 0
  };
  A._FileSink_close_closure.prototype = {
    call$1(_) {
      return this.$this._completer.complete$0();
    },
    $signature: typesOffset + 15
  };
  A._FileSink_close_closure0.prototype = {
    call$2(error, stackTrace) {
      return this.$this._completer.completeError$2(error, stackTrace);
    },
    $signature: 44
  };
  A._FileSink__addData_closure.prototype = {
    call$1(node) {
      var t1 = this.data,
        existing = node._content,
        t2 = existing.length,
        t3 = J.get$length$asx(t1);
      t3 = new Uint8Array(t2 + t3);
      node._content = t3;
      C.NativeUint8List_methods.setRange$3(t3, 0, t2, existing);
      t3 = node._content;
      C.NativeUint8List_methods.setRange$3(t3, t2, t3.length, t1);
      return node;
    },
    $signature: typesOffset + 16
  };
  A._MemoryFileSystem_findNode_subpath.prototype = {
    call$0() {
      return C.JSArray_methods.join$1(C.JSArray_methods.sublist$2(this.parts, 0, this.i + 1), this.$this._memory_file_system$_context.style.get$separator());
    },
    $signature: 14
  };
  A._MemoryFileSystem_findNode_closure.prototype = {
    call$3($parent, childName, child) {
      return this.segmentVisitor.call$5($parent, childName, child, this.i, this.finalSegment);
    },
    $signature: typesOffset + 4
  };
  A.MemoryFileSystemEntity_backing_closure.prototype = {
    call$0() {
      return this.$this.path;
    },
    $signature: 14
  };
  A.MemoryFileSystemEntity_resolvedBacking_closure.prototype = {
    call$0() {
      return this.$this.path;
    },
    $signature: 14
  };
  A.MemoryFileSystemEntity_resolvedBacking_closure0.prototype = {
    call$0() {
      return this.$this.path;
    },
    $signature: 14
  };
  A.MemoryFileSystemEntity_defaultCheckType_closure.prototype = {
    call$0() {
      return this.$this.path;
    },
    $signature: 14
  };
  A.MemoryFileSystemEntity_internalCreateSync_closure.prototype = {
    call$5($parent, childName, child, currentSegment, finalSegment) {
      if (child == null) {
        child = this.createChild.call$2($parent, currentSegment === finalSegment);
        if (child != null)
          $parent.children.$indexSet(0, childName, child);
      }
      return child;
    },
    $signature: typesOffset + 18
  };
  A.resolveLinks_closure.prototype = {
    call$3($parent, childName, child) {
      var t1 = this.tailVisitor,
        t2 = t1 != null;
      if (t2)
        child.get$type();
      return t2 ? t1.call$3($parent, childName, child) : child;
    },
    $signature: typesOffset + 4
  };
  A.ErrorCodes_EINVAL_closure.prototype = {
    call$1(codes) {
      return 22;
    },
    $signature: typesOffset + 0
  };
  A.ErrorCodes_EISDIR_closure.prototype = {
    call$1(codes) {
      return 21;
    },
    $signature: typesOffset + 0
  };
  A.ErrorCodes_ELOOP_closure.prototype = {
    call$1(codes) {
      return 40;
    },
    $signature: typesOffset + 0
  };
  A.ErrorCodes_ENOENT_closure.prototype = {
    call$1(codes) {
      return 2;
    },
    $signature: typesOffset + 0
  };
  A.ErrorCodes_ENOTDIR_closure.prototype = {
    call$1(codes) {
      return 20;
    },
    $signature: typesOffset + 0
  };
  A.ErrorCodes_ENOTEMPTY_closure.prototype = {
    call$1(codes) {
      return 39;
    },
    $signature: typesOffset + 0
  };
  A.FontLoader_addFont_closure.prototype = {
    call$1(data) {
      return J.asUint8List$2$x(C.NativeByteData_methods.get$buffer(data), data.byteOffset, data.byteLength);
    },
    $signature: 559
  };
  A.FontLoader_load_closure.prototype = {
    call$1(f) {
      return f.then$1$1(new A.FontLoader_load__closure(this.$this), type$.void);
    },
    $signature: 560
  };
  A.FontLoader_load__closure.prototype = {
    call$1(list) {
      return A.loadFontFromList(list, this.$this.family);
    },
    $signature: 561
  };
  A.CacheManager_downloadFile_closure.prototype = {
    call$1(r) {
      return r instanceof A.FileInfo;
    },
    $signature: typesOffset + 19
  };
  A.CacheStore_closure.prototype = {
    call$1(value) {
      return this.config.repo;
    },
    $signature: typesOffset + 20
  };
  A.CacheStore_retrieveCacheData_closure.prototype = {
    call$1(cacheObject) {
      return this.$call$body$CacheStore_retrieveCacheData_closure(cacheObject);
    },
    $call$body$CacheStore_retrieveCacheData_closure(cacheObject) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.Null),
        $async$self = this, t1, t2, t3;
      var $async$call$1 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.$this;
              t2 = $async$self.key;
              t3 = t1._cache_store$_memCache;
              if (cacheObject == null)
                t3.remove$1(0, t2);
              else
                t3.$indexSet(0, t2, cacheObject);
              $async$self.completer.complete$1(cacheObject);
              t1._futureCache.remove$1(0, t2);
              // implicit return
              return B._asyncReturn(null, $async$completer);
          }
      });
      return B._asyncStartSync($async$call$1, $async$completer);
    },
    $signature: typesOffset + 21
  };
  A.CacheStore__scheduleCleanup_closure.prototype = {
    call$0() {
      var t1 = this.$this;
      t1._scheduledCleanup = null;
      t1._cleanupCache$0();
    },
    $signature: 0
  };
  A.WebHelper__manageResponse_closure.prototype = {
    call$1(_) {
      var t1 = this.oldCacheObject.relativePath;
      if (this._box_0.newCacheObject.relativePath !== t1)
        this.$this._removeOldFile$1(t1);
    },
    $signature: 21
  };
  A.WebHelper__saveFileAndPostUpdates_closure.prototype = {
    call$1(s) {
      var t1 = this._box_0,
        receivedBytes = t1.receivedBytes + J.get$length$asx(s);
      t1.receivedBytes = receivedBytes;
      this.receivedBytesResultController.add$1(0, receivedBytes);
      return s;
    },
    $signature: 562
  };
  A.post_closure.prototype = {
    call$1(client) {
      var _this = this;
      return client._sendUnstreamed$5("POST", _this.url, _this.headers, _this.body, _this.encoding);
    },
    $signature: typesOffset + 22
  };
  A.BehaviorSubject__deferStream_closure.prototype = {
    call$0() {
      var value, t2, _this = this,
        t1 = _this.wrapper,
        errorAndStackTrace = t1.errorAndStackTrace;
      if (errorAndStackTrace != null && !t1.isValue) {
        t1 = _this.controller;
        return new A.StartWithErrorStreamTransformer(errorAndStackTrace.error, errorAndStackTrace.stackTrace, _this.T._eval$1("StartWithErrorStreamTransformer<0>")).bind$1(new B._BroadcastStream(t1, B._instanceType(t1)._eval$1("_BroadcastStream<1>")));
      }
      value = t1.value;
      if (value !== D.C__Empty && t1.isValue) {
        t1 = _this.controller;
        t2 = _this.T;
        return new A.StartWithStreamTransformer(t2._as(value), t2._eval$1("StartWithStreamTransformer<0>")).bind$1(new B._BroadcastStream(t1, B._instanceType(t1)._eval$1("_BroadcastStream<1>")));
      }
      t1 = _this.controller;
      return new B._BroadcastStream(t1, B._instanceType(t1)._eval$1("_BroadcastStream<1>"));
    },
    $signature() {
      return this.T._eval$1("Stream<0>()");
    }
  };
  A.StartWithStreamTransformer_bind_closure.prototype = {
    call$0() {
      var t1 = this.$this;
      return new A._StartWithStreamSink(t1.startValue, t1.$ti._eval$1("_StartWithStreamSink<1>"));
    },
    $signature() {
      return this.$this.$ti._eval$1("_StartWithStreamSink<1>()");
    }
  };
  A.StartWithErrorStreamTransformer_bind_closure.prototype = {
    call$0() {
      var t1 = this.$this;
      return new A._StartWithErrorStreamSink(t1.error, t1.stackTrace, t1.$ti._eval$1("_StartWithErrorStreamSink<1>"));
    },
    $signature() {
      return this.$this.$ti._eval$1("_StartWithErrorStreamSink<1>()");
    }
  };
  A._forwardMulti_closure.prototype = {
    call$1(controller) {
      var t1 = {},
        sink = this.sinkFactory.call$0();
      sink._forwarding_sink$_sink = new A._MultiControllerSink(controller, this.R._eval$1("_MultiControllerSink<0>"));
      t1.subscription = null;
      t1.cancelled = false;
      sink.onListen$0();
      new A._forwardMulti_closure_listenToUpstream(t1, this.stream, sink).call$0();
      controller.onCancel = new A._forwardMulti__closure(t1, sink);
    },
    $signature() {
      return this.R._eval$1("~(MultiStreamController<0>)");
    }
  };
  A._forwardMulti_closure_listenToUpstream.prototype = {
    call$1(_) {
      var t2, t3, t4,
        t1 = this._box_0;
      if (t1.cancelled)
        return;
      t2 = this.sink;
      t3 = t2.get$onData();
      t4 = t2.get$onError();
      t1.subscription = this.stream.listen$3$onDone$onError(t3, t2.get$onDone(), t4);
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 218
  };
  A._forwardMulti__closure.prototype = {
    call$0() {
      var t2, future,
        t1 = this._box_0;
      t1.cancelled = true;
      t2 = t1.subscription;
      future = t2 == null ? null : t2.cancel$0();
      t1.subscription = null;
      return A.waitTwoFutures(future, this.sink.onCancel$0());
    },
    $signature: 0
  };
  A._forward_closure.prototype = {
    call$0() {
      return this.sinkFactory.call$0();
    },
    $signature() {
      return this.T._eval$1("@<0>")._bind$1(this.R)._eval$1("ForwardingSink<1,2>()");
    }
  };
  A._forward_closure0.prototype = {
    call$0() {
      var _this = this,
        t1 = _this.sink,
        t2 = _this.controller;
      t1._readFinal$0()._forwarding_sink$_sink = new A._EnhancedEventSink(t2, _this.R._eval$1("_EnhancedEventSink<0>"));
      t1._readFinal$0().onListen$0();
      new A._forward_closure_listenToUpstream(_this._box_0, _this.stream, t1, t2).call$0();
    },
    $signature: 0
  };
  A._forward_closure_listenToUpstream.prototype = {
    call$1(_) {
      var t2, t3, t4, t5, _this = this,
        t1 = _this._box_0;
      if (t1.cancelled)
        return;
      t2 = _this.stream;
      t3 = _this.sink;
      t4 = t3._readFinal$0().get$onData();
      t5 = t3._readFinal$0().get$onError();
      t1.subscription = t2.listen$3$onDone$onError(t4, t3._readFinal$0().get$onDone(), t5);
      t3._readFinal$0();
      if (!t2.get$isBroadcast()) {
        t2 = _this.controller;
        t2.set$onPause(new A._forward__listenToUpstream_closure(t1, t3));
        t2.set$onResume(new A._forward__listenToUpstream_closure0(t1, t3));
      }
    },
    call$0() {
      return this.call$1(null);
    },
    $signature: 218
  };
  A._forward__listenToUpstream_closure.prototype = {
    call$0() {
      this._box_0.subscription.pause$0();
      this.sink._readFinal$0().onPause$0();
    },
    $signature: 0
  };
  A._forward__listenToUpstream_closure0.prototype = {
    call$0() {
      this._box_0.subscription.resume$0();
      this.sink._readFinal$0().onResume$0();
    },
    $signature: 0
  };
  A._forward_closure1.prototype = {
    call$0() {
      var t2, future,
        t1 = this._box_0;
      t1.cancelled = true;
      t2 = t1.subscription;
      future = t2 == null ? null : t2.cancel$0();
      t1.subscription = null;
      t1 = this.sink;
      t1._readFinal$0();
      return A.waitTwoFutures(future, t1._readFinal$0().onCancel$0());
    },
    $signature: 0
  };
  A.FontFile_fromId_closure.prototype = {
    call$1(e) {
      return J.toString$0$(e);
    },
    $signature: 564
  };
  (function aliases() {
    var _ = A.HeaderOfText.prototype;
    _.super$HeaderOfText$fallback = _.fallback$1;
  })();
  (function installTearOffs() {
    var _instance_0_i = hunkHelpers._instance_0i,
      _static_2 = hunkHelpers._static_2,
      _instance_1_u = hunkHelpers._instance_1u,
      _static_1 = hunkHelpers._static_1,
      _instance_1_i = hunkHelpers._instance_1i,
      _instance_2_u = hunkHelpers._instance_2u,
      _instance_0_u = hunkHelpers._instance_0u,
      _instance = hunkHelpers.installInstanceTearOff,
      _static_0 = hunkHelpers._static_0;
    _instance_0_i(A._File.prototype, "get$length", "length$0", 3);
    _instance_0_i(A.MemoryFile.prototype, "get$length", "length$0", 3);
    _static_2(A, "memory_file_system___defaultOpHandle$closure", "_defaultOpHandle", 27);
    _instance_1_u(A.MemoryFileSystemEntity.prototype, "get$defaultCheckType", "defaultCheckType$1", 17);
    _static_1(A, "utils__isEmpty$closure", "isEmpty", 28);
    _instance_1_i(A.Subject.prototype, "get$add", "add$1", 1);
    var _;
    _instance_1_u(_ = A._StartWithStreamSink.prototype, "get$onData", "onData$1", 1);
    _instance_2_u(_, "get$onError", "onError$2", 5);
    _instance_0_u(_, "get$onDone", "onDone$0", 2);
    _instance_1_u(_ = A._StartWithErrorStreamSink.prototype, "get$onData", "onData$1", 1);
    _instance_2_u(_, "get$onError", "onError$2", 5);
    _instance_0_u(_, "get$onDone", "onDone$0", 2);
    _instance_1_u(_ = A.Chapter.prototype, "get$_addHolderFromStream", "_addHolderFromStream$1", 23);
    _instance(_, "get$addAndRegisterError", 0, 1, null, ["call$2", "call$1"], ["addAndRegisterError$2", "addAndRegisterError$1"], 24, 0, 0);
    _instance_0_u(_, "get$postLoadCleanup", "postLoadCleanup$0", 2);
    _instance_1_u(_ = A.FontFile.prototype, "get$_markLoaded", "_markLoaded$1", 25);
    _instance_2_u(_, "get$_downloadError", "_downloadError$2", 26);
    _instance_2_u(_ = A.FutureHolder.prototype, "get$futureBuilder", "futureBuilder$2", 6);
    _instance_2_u(_, "get$fallbackFutureBuilder", "fallbackFutureBuilder$2", 6);
    _static_0(A, "clock__systemTime$closure", "systemTime", 29);
  })();
  (function inheritance() {
    var _mixin = hunkHelpers.mixin,
      _inheritMany = hunkHelpers.inheritMany,
      _inherit = hunkHelpers.inherit;
    _inheritMany(B.Object, [A.HttpException, A._HeaderValue, A.StreamTransformerBase, A.OSError, A.FileSystemEntity, A.FileMode, A.FileSystemException, A.FileSystemEntityType, A._JSSecureRandom, A.Clock, A.DynamicCachedFonts, A._FontFileExtensionManager, A.Clock0, A.MemoryFileSystemEntity, A._FileSink, A.MemoryFileStat, A.FileSystem, A.Node, A.FileSystemOp, A.FileSystemStyle, A.DirectoryAddOnsMixin, A._LinuxCodes, A.FontLoader, A.CacheManager, A.CacheStore, A.Config, A.CacheLogger, A.FileResponse, A.NonStoringObjectProvider, A.CacheObject, A.MemoryCacheSystem, A.FileService, A.HttpGetResponse, A.QueueItem, A.WebHelper, A._Wrapper, A.ForwardingSink, A._Empty, A.ErrorAndStackTrace, A._MultiControllerSink, A._EnhancedEventSink, A.ChapterInfo, A.ChapterParser, A.BookCodeException, A.FontException, A.FontFile, A.FontCache, A.FontInterm, A.Wousi, A.LiveFont, A.LiveTextHolder, A.FragOfText, A.RNG, A.Uuid, A.UuidV1]);
    _inheritMany(B.Closure2Args, [A._HeaderValue_toString_closure, A.HashMap_HashMap$from_closure, A.MemoryDirectory_createSync_closure, A.MemoryFile__doCreate_closure, A._FileSink_addStream_closure1, A._FileSink_close_closure0]);
    _inheritMany(B.Closure0Args, [A._HeaderValue__parse_done, A._HeaderValue__parse_skipWS, A._HeaderValue__parse_parseValue, A._HeaderValue__parse_parseParameters, A._HeaderValue__parse_parseParameters_parseParameterName, A._HeaderValue__parse_parseParameters_parseParameterValue, A.Future_Future$microtask_closure, A._MultiStream_listen_closure, A.MemoryDirectory_createTempSync_closure, A.MemoryDirectory_createTempSync_closure0, A.MemoryDirectory_createTempSync_name, A.MemoryFile__resolvedBackingOrCreate_closure, A.MemoryFile__resolvedBackingOrCreate_closure0, A._FileSink__FileSink$fromFile_closure, A._FileSink_addStream_closure0, A._MemoryFileSystem_findNode_subpath, A.MemoryFileSystemEntity_backing_closure, A.MemoryFileSystemEntity_resolvedBacking_closure, A.MemoryFileSystemEntity_resolvedBacking_closure0, A.MemoryFileSystemEntity_defaultCheckType_closure, A.CacheStore__scheduleCleanup_closure, A.BehaviorSubject__deferStream_closure, A.StartWithStreamTransformer_bind_closure, A.StartWithErrorStreamTransformer_bind_closure, A._forwardMulti__closure, A._forward_closure, A._forward_closure0, A._forward__listenToUpstream_closure, A._forward__listenToUpstream_closure0, A._forward_closure1]);
    _inheritMany(B.Closure, [A._HeaderValue__parse_expect, A._HeaderValue__parse_maybeExpect, A._Directory__delete_closure, A._File__delete_closure, A._File__delete_closure0, A._File_length_closure, A.DynamicCachedFonts_load_closure, A.DynamicCachedFonts_load_closure0, A.DynamicCachedFonts_load_closure1, A._FontFileExtensionManager_matchesFileExtension_closure, A._FileSink_addStream_closure, A._FileSink_close_closure, A._FileSink__addData_closure, A._MemoryFileSystem_findNode_closure, A.MemoryFileSystemEntity_internalCreateSync_closure, A.resolveLinks_closure, A.ErrorCodes_EINVAL_closure, A.ErrorCodes_EISDIR_closure, A.ErrorCodes_ELOOP_closure, A.ErrorCodes_ENOENT_closure, A.ErrorCodes_ENOTDIR_closure, A.ErrorCodes_ENOTEMPTY_closure, A.FontLoader_addFont_closure, A.FontLoader_load_closure, A.FontLoader_load__closure, A.CacheManager_downloadFile_closure, A.CacheStore_closure, A.CacheStore_retrieveCacheData_closure, A.WebHelper__manageResponse_closure, A.WebHelper__saveFileAndPostUpdates_closure, A.post_closure, A._forwardMulti_closure, A._forwardMulti_closure_listenToUpstream, A._forward_closure_listenToUpstream, A.FontFile_fromId_closure]);
    _inherit(A._ContentType, A._HeaderValue);
    _inheritMany(B.Stream, [A._MultiStream, A.DeferStream, A._BehaviorSubjectStream, A._SubjectStream]);
    _inherit(A._MultiStreamController, B._AsyncStreamController);
    _inheritMany(A.FileSystemEntity, [A._Directory, A._File]);
    _inheritMany(A.FileSystemException, [A.PathAccessException, A.PathExistsException, A.PathNotFoundException]);
    _inherit(A._RealtimeClock, A.Clock0);
    _inheritMany(A.MemoryFileSystemEntity, [A._MemoryDirectory_MemoryFileSystemEntity_DirectoryAddOnsMixin, A.MemoryFile]);
    _inherit(A.MemoryDirectory, A._MemoryDirectory_MemoryFileSystemEntity_DirectoryAddOnsMixin);
    _inherit(A._MemoryFileSystem, A.FileSystem);
    _inherit(A.RealNode, A.Node);
    _inheritMany(A.RealNode, [A.DirectoryNode, A.FileNode]);
    _inherit(A.RootNode, A.DirectoryNode);
    _inherit(A._Posix, A.FileSystemStyle);
    _inheritMany(A.FileResponse, [A.DownloadProgress, A.FileInfo]);
    _inherit(A.HttpFileService, A.FileService);
    _inherit(A.HttpExceptionWithStatus, A.HttpException);
    _inherit(A.Subject, E.StreamView);
    _inherit(A.BehaviorSubject, A.Subject);
    _inheritMany(A.ForwardingSink, [A._StartWithStreamSink, A._StartWithErrorStreamSink]);
    _inheritMany(A.StreamTransformerBase, [A.StartWithStreamTransformer, A.StartWithErrorStreamTransformer]);
    _inherit(A.Chapter, B.ChangeNotifier);
    _inheritMany(B._Enum, [A._LoadStatus, A.CodeElementType]);
    _inheritMany(A.FragOfText, [A.LiveFragment, A.ColoredBoxFrag, A.FragBody, A.FragCustom]);
    _inheritMany(B.Holder, [A.LiveSpanOfText, A.UnhandledCodeElement, A.FutureHolder, A.NewlineElement, A.ColoredBoxHolder, A.PageBreakOfText, A.SpanOfText, A.TextHolder, A.HiddenTextElement]);
    _inherit(A.UnhandledSpanHoldingCode, N.SpanHoldingCode);
    _inheritMany(A.TextHolder, [A.BodyTextElement, A.FontWanterTextHolder, A.AlignedBodyText, A.HeaderOfText]);
    _inheritMany(A.FontWanterTextHolder, [A.CustomFontText, A.HiliteFontText]);
    _inherit(A.CustomHeaderOfText, A.HeaderOfText);
    _inherit(A.CryptoRNG, A.RNG);
    _mixin(A._MemoryDirectory_MemoryFileSystemEntity_DirectoryAddOnsMixin, A.DirectoryAddOnsMixin);
  })();
  B._Universe_addRules(init.typeUniverse, JSON.parse('{"HttpException":{"Exception":[]},"_MultiStream":{"Stream":["1"],"Stream.T":"1"},"_MultiStreamController":{"_AsyncStreamController":["1"],"_AsyncStreamControllerDispatch":["1"],"_StreamController":["1"],"MultiStreamController":["1"]},"Directory":{"FileSystemEntity":[]},"_Directory":{"Directory":[],"FileSystemEntity":[]},"File":{"FileSystemEntity":[]},"_File":{"File":[],"FileSystemEntity":[]},"OSError":{"Exception":[]},"FileSystemException":{"Exception":[]},"PathAccessException":{"Exception":[]},"PathExistsException":{"Exception":[]},"PathNotFoundException":{"Exception":[]},"MemoryDirectory":{"Directory0":[],"FileSystemEntity0":[],"Directory":[],"FileSystemEntity":[]},"MemoryFile":{"File0":[],"FileSystemEntity0":[],"File":[],"FileSystemEntity":[]},"MemoryFileSystemEntity":{"FileSystemEntity0":[],"FileSystemEntity":[]},"RealNode":{"Node":[]},"DirectoryNode":{"Node":[]},"FileNode":{"Node":[]},"LinkNode":{"Node":[]},"RootNode":{"DirectoryNode":[],"Node":[]},"_LinuxCodes":{"_Codes":[]},"DownloadProgress":{"FileResponse":[]},"FileInfo":{"FileResponse":[]},"NonStoringObjectProvider":{"CacheInfoRepository":[]},"HttpGetResponse":{"FileServiceResponse":[]},"HttpExceptionWithStatus":{"Exception":[]},"DeferStream":{"Stream":["1"],"Stream.T":"1"},"BehaviorSubject":{"Subject":["1"],"Stream":["1"],"Stream.T":"1"},"_BehaviorSubjectStream":{"Stream":["1"],"Stream.T":"1"},"Subject":{"Stream":["1"]},"_SubjectStream":{"Stream":["1"],"Stream.T":"1"},"Chapter":{"Listenable":[]},"BookCodeException":{"Exception":[]},"FontException":{"Exception":[]},"LiveFragment":{"FragOfText":[]},"LiveSpanOfText":{"Holder":[]},"UnhandledCodeElement":{"Holder":[]},"FutureHolder":{"Holder":[]},"NewlineElement":{"Holder":[]},"ColoredBoxHolder":{"Holder":[]},"ColoredBoxFrag":{"FragOfText":[]},"PageBreakOfText":{"Holder":[]},"SpanOfText":{"Holder":[]},"FragBody":{"FragOfText":[]},"FragCustom":{"FragOfText":[]},"UnhandledSpanHoldingCode":{"SpanHoldingCode":[],"Holder":[]},"TextHolder":{"Holder":[]},"BodyTextElement":{"TextHolder":[],"Holder":[]},"FontWanterTextHolder":{"TextHolder":[],"Holder":[]},"AlignedBodyText":{"TextHolder":[],"Holder":[]},"HeaderOfText":{"TextHolder":[],"Holder":[]},"HiddenTextElement":{"Holder":[]},"CustomFontText":{"TextHolder":[],"Holder":[]},"HiliteFontText":{"TextHolder":[],"Holder":[]},"CustomHeaderOfText":{"TextHolder":[],"Holder":[]},"Directory0":{"FileSystemEntity0":[],"Directory":[],"FileSystemEntity":[]},"File0":{"FileSystemEntity0":[],"File":[],"FileSystemEntity":[]},"FileSystemEntity0":{"FileSystemEntity":[]}}'));
  B._Universe_addErasedTypes(init.typeUniverse, JSON.parse('{"MultiStreamController":1,"StreamTransformerBase":2,"ForwardingSink":2}'));
  var string$ = {
    You_ca: "You cannot add items while items are being added from addStream"
  };
  var type$ = (function rtii() {
    var findType = B.findType;
    return {
      BehaviorSubject_FileResponse: findType("BehaviorSubject<FileResponse>"),
      CacheInfoRepository: findType("CacheInfoRepository"),
      CacheObject: findType("CacheObject"),
      Chapter: findType("Chapter"),
      Directory: findType("Directory"),
      DirectoryNode: findType("DirectoryNode"),
      Directory_2: findType("Directory0"),
      Exception: findType("Exception"),
      File: findType("File"),
      FileInfo: findType("FileInfo"),
      FileNode: findType("FileNode"),
      FileResponse: findType("FileResponse"),
      FileServiceResponse: findType("FileServiceResponse"),
      FileSystemEntity: findType("FileSystemEntity0"),
      File_2: findType("File0"),
      FontFile: findType("FontFile"),
      FutureBuilder_Holder: findType("FutureBuilder<Holder>"),
      Future_nullable_CacheObject: findType("Future<CacheObject?>"),
      Future_void: findType("Future<~>"),
      Holder: findType("Holder"),
      Iterable_FileInfo: findType("Iterable<FileInfo>"),
      JSArray_CacheObject: findType("JSArray<CacheObject>"),
      JSArray_FileInfo: findType("JSArray<FileInfo>"),
      JSArray_FragOfText: findType("JSArray<FragOfText>"),
      JSArray_Future_Uint8List: findType("JSArray<Future<Uint8List>>"),
      JSArray_Holder: findType("JSArray<Holder>"),
      JSArray_InlineSpan: findType("JSArray<InlineSpan>"),
      JSArray_String: findType("JSArray<String>"),
      JSArray_int: findType("JSArray<int>"),
      LinkNode: findType("LinkNode"),
      List_CacheObject: findType("List<CacheObject>"),
      Node: findType("Node"),
      Null: findType("Null"),
      Object: findType("Object"),
      QueueItem: findType("QueueItem"),
      Response: findType("Response"),
      String: findType("String"),
      Uint8List: findType("Uint8List"),
      ValueKey_String: findType("ValueKey<String>"),
      _AsyncBroadcastStreamController_FileResponse: findType("_AsyncBroadcastStreamController<FileResponse>"),
      _AsyncCompleter_nullable_CacheObject: findType("_AsyncCompleter<CacheObject?>"),
      _AsyncCompleter_void: findType("_AsyncCompleter<~>"),
      _Future_ByteData: findType("_Future<ByteData>"),
      _Future_nullable_CacheObject: findType("_Future<CacheObject?>"),
      _Future_void: findType("_Future<~>"),
      _StreamIterator_FileResponse: findType("_StreamIterator<FileResponse>"),
      _StreamIterator_int: findType("_StreamIterator<int>"),
      _SyncStarIterable_FragOfText: findType("_SyncStarIterable<FragOfText>"),
      _SyncStarIterable_Holder: findType("_SyncStarIterable<Holder>"),
      _Wrapper_FileResponse: findType("_Wrapper<FileResponse>"),
      bool: findType("bool"),
      dynamic: findType("@"),
      int: findType("int"),
      nullable_CacheObject: findType("CacheObject?"),
      nullable_ChapterInfo: findType("ChapterInfo?"),
      nullable_DirectoryNode: findType("DirectoryNode?"),
      nullable_FileInfo: findType("FileInfo?"),
      nullable_FontFile: findType("FontFile?"),
      nullable_String: findType("String?"),
      void: findType("~")
    };
  })();
  (function constants() {
    var makeConstList = hunkHelpers.makeConstList;
    D.C_Clock = new A.Clock();
    D.C_FileMode = new A.FileMode();
    D.C_FileMode0 = new A.FileMode();
    D.C_HiddenTextElement = new A.HiddenTextElement();
    D.C_PageBreakOfText = new A.PageBreakOfText();
    D.C_Uuid = new A.Uuid();
    D.C__Empty = new A._Empty();
    D.C__LinuxCodes = new A._LinuxCodes();
    D.C__Posix = new A._Posix();
    D.C__RealtimeClock = new A._RealtimeClock();
    D.CodeElementType_0 = new A.CodeElementType(0, "parsedCodeElement");
    D.CodeElementType_1 = new A.CodeElementType(1, "codeBlock");
    D.CodeElementType_2 = new A.CodeElementType(2, "codeTag");
    D.Codes_10_0_NEWLINE = new F.Codes(10, 0, "NEWLINE");
    D.Codes_59_15_SEMICOLON = new F.Codes(59, 15, "SEMICOLON");
    D.Codes_60_16_LGATOR = new F.Codes(60, 16, "LGATOR");
    D.Codes_62_18_RGATOR = new F.Codes(62, 18, "RGATOR");
    D.Codes_91_23_LSQR = new F.Codes(91, 23, "LSQR");
    D.Color_rsC = new B.Color(0.7333333333333333, 1, 1, 1, C.ColorSpace_0);
    D.Color_xMg = new B.Color(0.43529411764705883, 0.4666666666666667, 0, 0.4666666666666667, C.ColorSpace_0);
    D.DeveloperException_mQb = new P.DeveloperException("Update CodeElementTypes if ladder");
    D.Duration_10000000 = new B.Duration(10000000);
    D.Duration_2592000000000 = new B.Duration(2592e9);
    D.Duration_31536000000000 = new B.Duration(31536e9);
    D.Duration_604800000000 = new B.Duration(6048e8);
    D.FileSystemEntityType_0 = new A.FileSystemEntityType(0);
    D.FileSystemEntityType_1 = new A.FileSystemEntityType(1);
    D.FileSystemEntityType_2 = new A.FileSystemEntityType(2);
    D.FileSystemException_LN3 = new A.FileSystemException("All nodes must have a parent.", "", null);
    D.FileSystemOp_0 = new A.FileSystemOp(0);
    D.FileSystemOp_2 = new A.FileSystemOp(2);
    D.FileSystemOp_3 = new A.FileSystemOp(3);
    D.FileSystemOp_4 = new A.FileSystemOp(4);
    D.FileSystemOp_6 = new A.FileSystemOp(6);
    D.IconData_57737_MaterialIcons_null_false = new B.IconData(57737, "MaterialIcons", null, false);
    D.IconData_58258_MaterialIcons_null_false = new B.IconData(58258, "MaterialIcons", null, false);
    D.List_200_202 = B._setArrayType(makeConstList([200, 202]), type$.JSArray_int);
    D.List_304 = B._setArrayType(makeConstList([304]), type$.JSArray_int);
    D.List_V5i = B._setArrayType(makeConstList(["file", "directory", "link", "unixDomainSock", "pipe", "notFound"]), type$.JSArray_String);
    D.Object_dDl = {"application/vnd.android.package-archive": 0, "application/epub+zip": 1, "application/gzip": 2, "application/java-archive": 3, "application/json": 4, "application/ld+json": 5, "application/msword": 6, "application/octet-stream": 7, "application/ogg": 8, "application/pdf": 9, "application/php": 10, "application/rtf": 11, "application/vnd.amazon.ebook": 12, "application/vnd.apple.installer+xml": 13, "application/vnd.mozilla.xul+xml": 14, "application/vnd.ms-excel": 15, "application/vnd.ms-fontobject": 16, "application/vnd.ms-powerpoint": 17, "application/vnd.oasis.opendocument.presentation": 18, "application/vnd.oasis.opendocument.spreadsheet": 19, "application/vnd.oasis.opendocument.text": 20, "application/vnd.openxmlformats-officedocument.presentationml.presentation": 21, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": 22, "application/vnd.openxmlformats-officedocument.wordprocessingml.document": 23, "application/vnd.rar": 24, "application/vnd.visio": 25, "application/x-7z-compressed": 26, "application/x-abiword": 27, "application/x-bzip": 28, "application/x-bzip2": 29, "application/x-csh": 30, "application/x-freearc": 31, "application/x-sh": 32, "application/x-shockwave-flash": 33, "application/x-tar": 34, "application/xhtml+xml": 35, "application/xml": 36, "application/zip": 37, "audio/3gpp": 38, "audio/3gpp2": 39, "audio/aac": 40, "audio/x-aac": 41, "audio/midi": 42, "audio/x-midi": 43, "audio/x-m4a": 44, "audio/m4a": 45, "audio/mpeg": 46, "audio/ogg": 47, "audio/opus": 48, "audio/wav": 49, "audio/x-wav": 50, "audio/webm": 51, "font/otf": 52, "font/ttf": 53, "font/woff": 54, "font/woff2": 55, "image/bmp": 56, "image/gif": 57, "image/jpeg": 58, "image/png": 59, "image/svg+xml": 60, "image/tiff": 61, "image/vnd.microsoft.icon": 62, "image/webp": 63, "text/calendar": 64, "text/css": 65, "text/csv": 66, "text/html": 67, "text/javascript": 68, "text/plain": 69, "text/xml": 70, "video/3gpp": 71, "video/3gpp2": 72, "video/mp2t": 73, "video/mpeg": 74, "video/ogg": 75, "video/webm": 76, "video/x-msvideo": 77, "video/quicktime": 78};
    D.Map_Iuz2d = new B.ConstantStringMap(D.Object_dDl, [".apk", ".epub", ".gz", ".jar", ".json", ".jsonld", ".doc", ".bin", ".ogx", ".pdf", ".php", ".rtf", ".azw", ".mpkg", ".xul", ".xls", ".eot", ".ppt", ".odp", ".ods", ".odt", ".pptx", ".xlsx", ".docx", ".rar", ".vsd", ".7z", ".abw", ".bz", ".bz2", ".csh", ".arc", ".sh", ".swf", ".tar", ".xhtml", ".xml", ".zip", ".3gp", ".3g2", ".aac", ".aac", ".midi", ".midi", ".m4a", ".m4a", ".mp3", ".oga", ".opus", ".wav", ".wav", ".weba", ".otf", ".ttf", ".woff", ".woff2", ".bmp", ".gif", ".jpg", ".png", ".svg", ".tiff", ".ico", ".webp", ".ics", ".css", ".csv", ".html", ".js", ".txt", ".xml", ".3gp", ".3g2", ".ts", ".mpeg", ".ogv", ".webm", ".avi", ".mov"], B.findType("ConstantStringMap<String,String>"));
    D.Map_empty3 = new B.ConstantStringMap(C.Object_empty, [], B.findType("ConstantStringMap<String,String?>"));
    D.TriWizardLoader_null1 = new B.TriWizardLoader(null);
    D.SizedBox_ldY0 = new B.SizedBox(null, 150, D.TriWizardLoader_null1, null);
    D.TriWizardLoader_null2 = new B.TriWizardLoader(null);
    D.SizedBox_ldY = new B.SizedBox(null, 150, D.TriWizardLoader_null2, null);
    D.SizedBox_null_240_null_null = new B.SizedBox(null, 240, null, null);
    D.WidgetSpan_uDf = new B.WidgetSpan(I.CircularProgressIndicator_null_null, C.PlaceholderAlignment_4, null, null);
    D._LoadStatus_0 = new A._LoadStatus(0, "unloaded");
    D._LoadStatus_1 = new A._LoadStatus(1, "loading");
    D._LoadStatus_2 = new A._LoadStatus(2, "loaded");
    D._LoadStatus_3 = new A._LoadStatus(3, "failed");
  })();
  (function staticFields() {
    $.FontCache__instance = null;
    $.V1State_nodeId = B._setArrayType([], type$.JSArray_int);
    $.V1State_clockSeq = 0;
    $.V1State_mSecs = 0;
    $.V1State_nSecs = 0;
    $.V1State_initialized = false;
  })();
  (function lazyInitializers() {
    var _lazyFinal = hunkHelpers.lazyFinal,
      _lazy = hunkHelpers.lazy;
    _lazyFinal($, "_ioOverridesToken", "$get$_ioOverridesToken", () => new B.Object());
    _lazyFinal($, "Platform_operatingSystem", "$get$Platform_operatingSystem", () => A._Platform_operatingSystem());
    _lazyFinal($, "Platform_isWindows", "$get$Platform_isWindows", () => {
      $.$get$Platform_operatingSystem();
      return false;
    });
    _lazyFinal($, "Random__secureRandom", "$get$Random__secureRandom", () => {
      var t1 = new A._JSSecureRandom(B.NativeByteData_NativeByteData(8));
      t1._JSSecureRandom$0();
      return t1;
    });
    _lazyFinal($, "_clockKey", "$get$_clockKey", () => new B.Object());
    _lazyFinal($, "DynamicCachedFontsCacheManager__cacheManagers", "$get$DynamicCachedFontsCacheManager__cacheManagers", () => {
      var _s30_ = "DynamicCachedFontsFontCacheKey";
      return B.LinkedHashMap_LinkedHashMap$_literal([_s30_, A.CacheManager$(A.Config$(_s30_, 200, D.Duration_31536000000000))], type$.String, B.findType("CacheManager"));
    });
    _lazyFinal($, "Utils__fontFileExtensionManager", "$get$Utils__fontFileExtensionManager", () => {
      var t1 = new A._FontFileExtensionManager(B.LinkedHashMap_LinkedHashMap$_empty(type$.String, B.findType("List<int>"))),
        t2 = type$.JSArray_int;
      t1.addExtension$2$extension$magicNumber("ttf", B._setArrayType([0, 1, 0, 0, 0], t2));
      t1.addExtension$2$extension$magicNumber("otf", B._setArrayType([79, 84, 84, 79, 0], t2));
      return t1;
    });
    _lazyFinal($, "_systemTempCounter", "$get$_systemTempCounter", () => B.Expando$(type$.int));
    _lazy($, "cacheLogger", "$get$cacheLogger", () => new A.CacheLogger());
    _lazy($, "V1State_random", "$get$V1State_random", () => new A.CryptoRNG());
    _lazyFinal($, "UuidParsing__byteToHex", "$get$UuidParsing__byteToHex", () => {
      var i,
        _list = J.JSArray_JSArray$allocateGrowable(256, type$.String);
      for (i = 0; i < 256; ++i)
        _list[i] = C.JSString_methods.padLeft$2(C.JSInt_methods.toRadixString$1(i, 16), 2, "0");
      return _list;
    });
    _lazyFinal($, "CryptoRNG__secureRandom", "$get$CryptoRNG__secureRandom", () => $.$get$Random__secureRandom());
  })();
};
;
((d, h) => {
  d[h] = d.current;
  d.eventLog.push({p: "main.dart.js_67", e: "endPart", h: h});
})($__dart_deferred_initializers__, "YjUkOBzQqR+bcArclezNKPxF1Gg=");
;