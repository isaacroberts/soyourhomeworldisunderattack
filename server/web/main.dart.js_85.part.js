// Generated by dart2js (, trust primitives, omit checks, lax runtime type, csp, intern-composite-values), the Dart to JavaScript compiler version: 3.8.0.
((s, d, e) => {
  s[d] = s[d] || {};
  s[d][e] = s[d][e] || [];
  s[d][e].push({p: "main.dart.js_85", e: "beginPart"});
})(self, "$__dart_deferred_initializers__", "eventLog");
$__dart_deferred_initializers__.current = function(hunkHelpers, init, holdersList, $) {
  var B, C,
  A = {SliverGridGeometry: function SliverGridGeometry(t0, t1, t2, t3) {
      var _ = this;
      _.scrollOffset = t0;
      _.crossAxisOffset = t1;
      _.mainAxisExtent = t2;
      _.crossAxisExtent = t3;
    }, SliverGridLayout: function SliverGridLayout() {
    }, SliverGridRegularTileLayout: function SliverGridRegularTileLayout(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.crossAxisCount = t0;
      _.mainAxisStride = t1;
      _.crossAxisStride = t2;
      _.childMainAxisExtent = t3;
      _.childCrossAxisExtent = t4;
      _.reverseCrossAxis = t5;
    }, SliverGridDelegate: function SliverGridDelegate() {
    }, SliverGridDelegateWithFixedCrossAxisCount: function SliverGridDelegateWithFixedCrossAxisCount(t0, t1, t2, t3) {
      var _ = this;
      _.crossAxisCount = t0;
      _.mainAxisSpacing = t1;
      _.crossAxisSpacing = t2;
      _.mainAxisExtent = t3;
    }, SliverGridParentData: function SliverGridParentData(t0, t1, t2) {
      var _ = this;
      _.index = _.crossAxisOffset = null;
      _._keptAlive = false;
      _.KeepAliveParentDataMixin_keepAlive = t0;
      _.ContainerParentDataMixin_previousSibling = t1;
      _.ContainerParentDataMixin_nextSibling = t2;
      _.layoutOffset = null;
    }, RenderSliverGrid: function RenderSliverGrid(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._gridDelegate = t0;
      _._childManager = t1;
      _._keepAliveBucket = t2;
      _.ContainerRenderObjectMixin__childCount = t3;
      _.ContainerRenderObjectMixin__firstChild = t4;
      _.ContainerRenderObjectMixin__lastChild = t5;
      _.parentData = _._geometry = null;
      _._depth = 0;
      _._object$_owner = _._object$_parent = null;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _.__RenderObject__wasRepaintBoundary_A = $;
      _._layerHandle = t6;
      _._needsCompositingBitsUpdate = false;
      _.__RenderObject__needsCompositing_A = $;
      _._needsPaint = true;
      _._needsCompositedLayerUpdate = false;
      _.__RenderObject__semantics_FI = $;
    },
    GridView$builder(gridDelegate, itemBuilder, itemCount) {
      var _null = null;
      return new A.GridView(gridDelegate, new B.SliverChildBuilderDelegate(itemBuilder, itemCount, true, true, true, B.scroll_delegate___kDefaultSemanticIndexCallback$closure(), _null), _null, C.Axis_1, false, _null, _null, C.AlwaysScrollableScrollPhysics_null, false, _null, itemCount, C.DragStartBehavior_1, _null, _null, C.Clip_1, C.HitTestBehavior_1, _null);
    },
    GridView: function GridView(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16) {
      var _ = this;
      _.gridDelegate = t0;
      _.childrenDelegate = t1;
      _.padding = t2;
      _.scrollDirection = t3;
      _.reverse = t4;
      _.controller = t5;
      _.primary = t6;
      _.physics = t7;
      _.shrinkWrap = t8;
      _.cacheExtent = t9;
      _.semanticChildCount = t10;
      _.dragStartBehavior = t11;
      _.keyboardDismissBehavior = t12;
      _.restorationId = t13;
      _.clipBehavior = t14;
      _.hitTestBehavior = t15;
      _.key = t16;
    },
    SliverGrid: function SliverGrid(t0, t1, t2) {
      this.gridDelegate = t0;
      this.delegate = t1;
      this.key = t2;
    }
  };
  B = holdersList[0];
  C = holdersList[2];
  A = hunkHelpers.updateHolder(holdersList[33], A);
  A.SliverGridGeometry.prototype = {
    getBoxConstraints$1(constraints) {
      var t1 = this.mainAxisExtent;
      return constraints.asBoxConstraints$3$crossAxisExtent$maxExtent$minExtent(this.crossAxisExtent, t1, t1);
    },
    toString$0(_) {
      var _this = this;
      return "SliverGridGeometry(" + C.JSArray_methods.join$1(B._setArrayType(["scrollOffset: " + B.S(_this.scrollOffset), "crossAxisOffset: " + B.S(_this.crossAxisOffset), "mainAxisExtent: " + B.S(_this.mainAxisExtent), "crossAxisExtent: " + B.S(_this.crossAxisExtent)], type$.JSArray_String), ", ") + ")";
    }
  };
  A.SliverGridLayout.prototype = {};
  A.SliverGridRegularTileLayout.prototype = {
    getMaxChildIndexForScrollOffset$1(scrollOffset) {
      var t1 = this.mainAxisStride;
      if (t1 > 0)
        return Math.max(0, this.crossAxisCount * C.JSNumber_methods.ceil$0(scrollOffset / t1) - 1);
      return 0;
    },
    _getOffsetFromStartInCrossAxis$1(crossAxisStart) {
      var t1, t2, _this = this;
      if (_this.reverseCrossAxis) {
        t1 = _this.crossAxisStride;
        t2 = _this.childCrossAxisExtent;
        return _this.crossAxisCount * t1 - crossAxisStart - t2 - (t1 - t2);
      }
      return crossAxisStart;
    },
    getGeometryForChildIndex$1(index) {
      var _this = this,
        t1 = _this.crossAxisCount,
        t2 = C.JSInt_methods.$mod(index, t1);
      return new A.SliverGridGeometry(C.JSInt_methods.$tdiv(index, t1) * _this.mainAxisStride, _this._getOffsetFromStartInCrossAxis$1(t2 * _this.crossAxisStride), _this.childMainAxisExtent, _this.childCrossAxisExtent);
    },
    computeMaxScrollOffset$1(childCount) {
      var t1;
      if (childCount === 0)
        return 0;
      t1 = this.mainAxisStride;
      return t1 * (C.JSInt_methods.$tdiv(childCount - 1, this.crossAxisCount) + 1) - (t1 - this.childMainAxisExtent);
    }
  };
  A.SliverGridDelegate.prototype = {};
  A.SliverGridDelegateWithFixedCrossAxisCount.prototype = {
    getLayout$1(constraints) {
      var _this = this,
        t1 = _this.crossAxisSpacing,
        t2 = _this.crossAxisCount,
        childCrossAxisExtent = Math.max(0, constraints.crossAxisExtent - t1 * (t2 - 1)) / t2,
        childMainAxisExtent = _this.mainAxisExtent;
      if (childMainAxisExtent == null)
        childMainAxisExtent = childCrossAxisExtent / 1;
      return new A.SliverGridRegularTileLayout(t2, childMainAxisExtent + _this.mainAxisSpacing, childCrossAxisExtent + t1, childMainAxisExtent, childCrossAxisExtent, B.axisDirectionIsReversed(constraints.crossAxisDirection));
    }
  };
  A.SliverGridParentData.prototype = {
    toString$0(_) {
      return "crossAxisOffset=" + B.S(this.crossAxisOffset) + "; " + this.super$SliverMultiBoxAdaptorParentData$toString(0);
    }
  };
  A.RenderSliverGrid.prototype = {
    setupParentData$1(child) {
      if (!(child.parentData instanceof A.SliverGridParentData))
        child.parentData = new A.SliverGridParentData(false, null, null);
    },
    set$gridDelegate(value) {
      var t1, t2, _this = this;
      if (_this._gridDelegate === value)
        return;
      t1 = true;
      if (B.getRuntimeTypeOfDartObject(value) === B.getRuntimeTypeOfDartObject(_this._gridDelegate)) {
        t2 = _this._gridDelegate;
        if (t2.crossAxisCount === value.crossAxisCount)
          if (t2.mainAxisSpacing === value.mainAxisSpacing)
            if (t2.crossAxisSpacing === value.crossAxisSpacing)
              t1 = t2.mainAxisExtent != value.mainAxisExtent;
      }
      if (t1)
        _this.markNeedsLayout$0();
      _this._gridDelegate = value;
    },
    childCrossAxisPosition$1(child) {
      var t1 = child.parentData;
      t1.toString;
      t1 = type$.SliverGridParentData._as(t1).crossAxisOffset;
      t1.toString;
      return t1;
    },
    performLayout$0() {
      var t2, scrollOffset, targetEndScrollOffset, layout, t3, firstIndex, targetLastIndex, leadingGarbage, firstChildGridGeometry, max, leadingScrollOffset, trailingScrollOffset, t4, index, trailingChildWithLayout, gridGeometry, t5, child, t6, t7, reachedEnd, childConstraints, t8, t9, estimatedTotalExtent, paintExtent, cacheExtent, _this = this, _null = null,
        constraints = type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(_this)),
        t1 = _this._childManager;
      t1._didUnderflow = false;
      t2 = constraints.scrollOffset;
      scrollOffset = t2 + constraints.cacheOrigin;
      targetEndScrollOffset = scrollOffset + constraints.remainingCacheExtent;
      layout = _this._gridDelegate.getLayout$1(constraints);
      t3 = layout.mainAxisStride;
      firstIndex = t3 > 1e-10 ? layout.crossAxisCount * C.JSNumber_methods.$tdiv(scrollOffset, t3) : 0;
      targetLastIndex = isFinite(targetEndScrollOffset) ? layout.getMaxChildIndexForScrollOffset$1(targetEndScrollOffset) : _null;
      if (_this.ContainerRenderObjectMixin__firstChild != null) {
        leadingGarbage = _this.calculateLeadingGarbage$1$firstIndex(firstIndex);
        _this.collectGarbage$2(leadingGarbage, targetLastIndex != null ? _this.calculateTrailingGarbage$1$lastIndex(targetLastIndex) : 0);
      } else
        _this.collectGarbage$2(0, 0);
      firstChildGridGeometry = layout.getGeometryForChildIndex$1(firstIndex);
      if (_this.ContainerRenderObjectMixin__firstChild == null)
        if (!_this.addInitialChild$2$index$layoutOffset(firstIndex, firstChildGridGeometry.scrollOffset)) {
          max = layout.computeMaxScrollOffset$1(t1.get$childCount());
          _this._geometry = B.SliverGeometry$(_null, false, _null, _null, max, 0, 0, 0, max, _null);
          t1.didFinishLayout$0();
          return;
        }
      leadingScrollOffset = firstChildGridGeometry.scrollOffset;
      trailingScrollOffset = leadingScrollOffset + firstChildGridGeometry.mainAxisExtent;
      t3 = _this.ContainerRenderObjectMixin__firstChild;
      t3.toString;
      t3 = t3.parentData;
      t3.toString;
      t4 = type$.SliverMultiBoxAdaptorParentData;
      t3 = t4._as(t3).index;
      t3.toString;
      index = t3 - 1;
      t3 = type$.SliverGridParentData;
      trailingChildWithLayout = _null;
      for (; index >= firstIndex; --index) {
        gridGeometry = layout.getGeometryForChildIndex$1(index);
        t5 = gridGeometry.mainAxisExtent;
        child = _this.insertAndLayoutLeadingChild$1(constraints.asBoxConstraints$3$crossAxisExtent$maxExtent$minExtent(gridGeometry.crossAxisExtent, t5, t5));
        t6 = child.parentData;
        t6.toString;
        t3._as(t6);
        t7 = gridGeometry.scrollOffset;
        t6.layoutOffset = t7;
        t6.crossAxisOffset = gridGeometry.crossAxisOffset;
        if (trailingChildWithLayout == null)
          trailingChildWithLayout = child;
        trailingScrollOffset = Math.max(trailingScrollOffset, t7 + t5);
      }
      if (trailingChildWithLayout == null) {
        t5 = _this.ContainerRenderObjectMixin__firstChild;
        t5.toString;
        t5.layout$1(firstChildGridGeometry.getBoxConstraints$1(constraints));
        trailingChildWithLayout = _this.ContainerRenderObjectMixin__firstChild;
        t5 = trailingChildWithLayout.parentData;
        t5.toString;
        t3._as(t5);
        t5.layoutOffset = leadingScrollOffset;
        t5.crossAxisOffset = firstChildGridGeometry.crossAxisOffset;
      }
      t5 = trailingChildWithLayout.parentData;
      t5.toString;
      t5 = t4._as(t5).index;
      t5.toString;
      index = t5 + 1;
      t5 = B._instanceType(_this)._eval$1("ContainerRenderObjectMixin.1");
      t6 = targetLastIndex != null;
      while (true) {
        if (!(!t6 || index <= targetLastIndex)) {
          reachedEnd = false;
          break;
        }
        gridGeometry = layout.getGeometryForChildIndex$1(index);
        t7 = gridGeometry.mainAxisExtent;
        childConstraints = constraints.asBoxConstraints$3$crossAxisExtent$maxExtent$minExtent(gridGeometry.crossAxisExtent, t7, t7);
        t8 = trailingChildWithLayout.parentData;
        t8.toString;
        child = t5._as(t8).ContainerParentDataMixin_nextSibling;
        if (child != null) {
          t8 = child.parentData;
          t8.toString;
          t8 = t4._as(t8).index;
          t8.toString;
          t8 = t8 !== index;
        } else
          t8 = true;
        if (t8) {
          child = _this.insertAndLayoutChild$2$after(childConstraints, trailingChildWithLayout);
          if (child == null) {
            reachedEnd = true;
            break;
          }
        } else
          child.layout$1(childConstraints);
        t8 = child.parentData;
        t8.toString;
        t3._as(t8);
        t9 = gridGeometry.scrollOffset;
        t8.layoutOffset = t9;
        t8.crossAxisOffset = gridGeometry.crossAxisOffset;
        trailingScrollOffset = Math.max(trailingScrollOffset, t9 + t7);
        ++index;
        trailingChildWithLayout = child;
      }
      t3 = _this.ContainerRenderObjectMixin__lastChild;
      t3.toString;
      t3 = t3.parentData;
      t3.toString;
      t3 = t4._as(t3).index;
      t3.toString;
      estimatedTotalExtent = reachedEnd ? trailingScrollOffset : t1.estimateMaxScrollOffset$5$firstIndex$lastIndex$leadingScrollOffset$trailingScrollOffset(constraints, firstIndex, t3, leadingScrollOffset, trailingScrollOffset);
      paintExtent = _this.calculatePaintOffset$3$from$to(constraints, Math.min(t2, leadingScrollOffset), trailingScrollOffset);
      cacheExtent = _this.calculateCacheOffset$3$from$to(constraints, leadingScrollOffset, trailingScrollOffset);
      _this._geometry = B.SliverGeometry$(cacheExtent, estimatedTotalExtent > paintExtent || t2 > 0 || constraints.overlap !== 0, _null, _null, estimatedTotalExtent, 0, paintExtent, 0, estimatedTotalExtent, _null);
      if (estimatedTotalExtent === trailingScrollOffset)
        t1._didUnderflow = true;
      t1.didFinishLayout$0();
    }
  };
  A.GridView.prototype = {
    buildChildLayout$1(context) {
      return new A.SliverGrid(this.gridDelegate, this.childrenDelegate, null);
    }
  };
  A.SliverGrid.prototype = {
    createRenderObject$1(context) {
      var t1 = new A.RenderSliverGrid(this.gridDelegate, type$.SliverMultiBoxAdaptorElement._as(context), B.LinkedHashMap_LinkedHashMap$_empty(type$.int, type$.RenderBox), 0, null, null, B.LayerHandle$(type$.ContainerLayer));
      t1.RenderObject$0();
      return t1;
    },
    updateRenderObject$2(context, renderObject) {
      renderObject.set$gridDelegate(this.gridDelegate);
    },
    estimateMaxScrollOffset$5(constraints, firstIndex, lastIndex, leadingScrollOffset, trailingScrollOffset) {
      var t1, t2;
      this.super$SliverMultiBoxAdaptorWidget$estimateMaxScrollOffset(constraints, firstIndex, lastIndex, leadingScrollOffset, trailingScrollOffset);
      t1 = this.gridDelegate.getLayout$1(constraints);
      t2 = this.delegate.get$estimatedChildCount();
      t2.toString;
      t2 = t1.computeMaxScrollOffset$1(t2);
      return t2;
    }
  };
  var typesOffset = hunkHelpers.updateTypes([]);
  (function inheritance() {
    var _inheritMany = hunkHelpers.inheritMany,
      _inherit = hunkHelpers.inherit;
    _inheritMany(B.Object, [A.SliverGridGeometry, A.SliverGridLayout, A.SliverGridDelegate]);
    _inherit(A.SliverGridRegularTileLayout, A.SliverGridLayout);
    _inherit(A.SliverGridDelegateWithFixedCrossAxisCount, A.SliverGridDelegate);
    _inherit(A.SliverGridParentData, B.SliverMultiBoxAdaptorParentData);
    _inherit(A.RenderSliverGrid, B.RenderSliverMultiBoxAdaptor);
    _inherit(A.GridView, B.BoxScrollView);
    _inherit(A.SliverGrid, B.SliverMultiBoxAdaptorWidget);
  })();
  B._Universe_addRules(init.typeUniverse, JSON.parse('{"SliverGridParentData":{"SliverMultiBoxAdaptorParentData":[],"ContainerParentDataMixin":["RenderBox"],"KeepAliveParentDataMixin":[],"ParentData":[]},"RenderSliverGrid":{"RenderSliverMultiBoxAdaptor":[],"RenderSliver":[],"ContainerRenderObjectMixin":["RenderBox","SliverMultiBoxAdaptorParentData"],"RenderObject":[],"DiagnosticableTree":[],"HitTestTarget":[],"ContainerRenderObjectMixin.1":"SliverMultiBoxAdaptorParentData","ContainerRenderObjectMixin.0":"RenderBox"},"GridView":{"StatelessWidget":[],"Widget":[],"DiagnosticableTree":[]},"SliverGrid":{"SliverMultiBoxAdaptorWidget":[],"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]}}'));
  var type$ = {
    ContainerLayer: B.findType("ContainerLayer"),
    JSArray_String: B.findType("JSArray<String>"),
    RenderBox: B.findType("RenderBox"),
    SliverConstraints: B.findType("SliverConstraints"),
    SliverGridParentData: B.findType("SliverGridParentData"),
    SliverMultiBoxAdaptorElement: B.findType("SliverMultiBoxAdaptorElement"),
    SliverMultiBoxAdaptorParentData: B.findType("SliverMultiBoxAdaptorParentData"),
    int: B.findType("int")
  };
};
;
((d, h) => {
  d[h] = d.current;
  d.eventLog.push({p: "main.dart.js_85", e: "endPart", h: h});
})($__dart_deferred_initializers__, "5gxghk93uT429EISmlU1FeVVCZ0=");
;